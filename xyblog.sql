/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50624
Source Host           : localhost:3306
Source Database       : xyblog

Target Server Type    : MYSQL
Target Server Version : 50624
File Encoding         : 65001

Date: 2020-03-31 22:19:00
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for blog_article_content
-- ----------------------------
DROP TABLE IF EXISTS `blog_article_content`;
CREATE TABLE `blog_article_content` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `article_id` bigint(40) NOT NULL COMMENT '对应的文章ID',
  `content` text NOT NULL COMMENT '文章内容',
  `content_format` text NOT NULL COMMENT '文章内容的网页显示格式',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1241970760717811714 DEFAULT CHARSET=utf8 COMMENT='文章内容表';

-- ----------------------------
-- Records of blog_article_content
-- ----------------------------
INSERT INTO `blog_article_content` VALUES ('33', '1', '# 个人介绍\n\n帝都的一个小码农\n\n喜欢数码、游戏、编程（为什么这个是最后）\n\n喜欢动漫、篮球（爱好太多了）\n\n希望你能喜欢我的网站。。。\n', '<h1 id=\"个人介绍\">个人介绍</h1>\n<p>帝都的一个小码农</p>\n<p>喜欢数码、游戏、编程（为什么这个是最后）</p>\n<p>喜欢动漫、篮球（爱好太多了）</p>\n<p>希望你能喜欢我的网站。。。</p>\n', '2020-03-18 13:49:02', '2020-03-18 13:49:02');
INSERT INTO `blog_article_content` VALUES ('1241670096041123841', '1241670095483281410', '# HTTP\n\n<a name=\"1a8d8590\"></a>\n## 一、基础概念\n\n<a name=\"c42ae579\"></a>\n### 什么是HTTP\n\nHTTP学名叫做超文本传输协议，是一个网络协议。\n\n是专门用来帮你传输诸如 HTML 的超媒体文档等 Web 内容滴。因为 HTML 本身就是超文本标记语言，HTML 中不仅有文本还有图片、音视频等内容，所以用来传输它的协议当然就叫超文本传输协议了\n\n<a name=\"1cc45ab7\"></a>\n### HTTP的基本性质\n\n总述：HTTP是简单的、可扩展、无状态的\n\n**HTTP 是简单的**\n\n即便在HTTP/2中把HTTP消息封装到了frames中，HTTP大体上还是被设计成可读的而且简单的。HTTP的消息能够让人读懂且明白它的意思，还允许简单的测试，放低了门槛，更有利于新来者了解。\n\n**HTTP 是可扩展的**\n\n在HTTP/1中就出现了, HTTP headers 让协议扩展变得非常容易。只要服务端和客户端在新的headers上语义达成一致，新的功能就可以轻松地被加进来。\n\n**HTTP 是无状态，有会话的**\n\nHTTP是无状态的：在同一个连接中，两个成功执行的请求之间是没有关系的。这就带来了一个问题，用户没办法在一个网站进行连续的交互，比如在一个电商网站里，用户把某个商品加入了购物车中，换了一个页面后再次添加商品，两次添加商品的请求没有联系，浏览器无法知道最终用户都选择了哪些商品。而用HTTP的头部扩展，**HTTP Cookies就可以解决这个问题**（将在后面介绍）。把Cookies添加到头部中，创建一个会话来让每次请求都能共享相同的上下文信息，相同的状态。**而HTTP的核心是无状态的，cookies的使用可以创建有状态的会话。**\n\n<a name=\"6f0533b7\"></a>\n### HTTP 协议如何使用 TCP 连接？\n\nHTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”）\n\n假设有一个网页，里面包含好多图片，还包含好多 外部的 CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对 每一个 外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）<br />相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。\n\n在 HTTP 1.0 版本，默认使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）.\n\n到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，默认采用的是“Keep-Alive”的方式。\n\n<a name=\"e364a069\"></a>\n### HTTP1.0、1.1、2.0之间的区别，不同版本的特点\n\n详细的解释在HTTPS那篇文章。\n\n- HTTP1.1与1.0之间的区别:\n  1. HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。而1.0不支持长连接。客户端和服务器每进行一次HTTP操作，就建立一次连接。\n  1. 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n  1. Host头处理：1.0请求的url并没有传递主机名(服务器与IP地址绑定)，1.1请求和响应都支持Host头域(虚拟主机共享IP地址)\n  1. 1.1新增24个错误状态响应码。409：请求的资源和资源的当前状态冲突，410：服务器资源永久性删除。\n  1. 带宽优化以及网络连接的使用：1.1允许只请求资源的某个部分.\n- HTTP2.0和HTTP1.X相比的新特性\n  1. 新的二进制格式：1.x的解析是基于文本的，而2.0的协议解析是采用二进制格式。\n  1. 多路复用，具体解释在HTTPS那篇\n  1. header压缩。\n  1. 服务端推送。\n\n<a name=\"URI\"></a>\n### URI\n\nURI 包含 URL 和 URN。\n\n<a name=\"6b954c92\"></a>\n### 请求和响应报文\n\n<a name=\"324d4210\"></a>\n#### 1. 请求报文\n\n![](https://cdn.nlark.com/yuque/0/2020/png/407890/1581734448103-68d310ef-be81-4fb0-b6e5-f2d7cad3e60c.png#align=left&display=inline&height=131&originHeight=221&originWidth=656&size=0&status=done&style=none&width=388)\n\n<a name=\"97fc6632\"></a>\n#### 2. 响应报文\n\n![](https://cdn.nlark.com/yuque/0/2020/png/407890/1581734462293-e998f98a-71a3-495c-bb2b-5308ab7ea030.png#align=left&display=inline&height=148&originHeight=267&originWidth=704&size=0&status=done&style=none&width=390)\n\n<a name=\"c8c706cc\"></a>\n## 二、HTTP方法\n\n客户端发送的 **请求报文** 第一行为请求行，包含了方法字段。\n\n<a name=\"GET\"></a>\n### GET\n\n> 获取资源\n\n\n当前网络请求中，绝大部分使用的是 GET 方法。\n\n<a name=\"HEAD\"></a>\n### HEAD\n\n> 获取报文首部\n\n\n和 GET 方法类似，但是不返回报文实体主体部分。\n\n主要用于确认 URL 的有效性以及资源更新的日期时间等。\n\n<a name=\"POST\"></a>\n### POST\n\n> 传输实体主体\n\n\nPOST 主要用来传输数据，而 GET 主要用来获取资源。\n\n更多 POST 与 GET 的比较请见第九章。\n\n<a name=\"PUT\"></a>\n### PUT\n\n> 上传文件\n\n\n由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。\n\n```\nPUT /new.html HTTP/1.1\nHost: example.com\nContent-type: text/html\nContent-length: 16\n\n<p>New File</p>\n```\n\n<a name=\"PATCH\"></a>\n### PATCH\n\n> 对资源进行部分修改\n\n\nPUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。\n\n```\nPATCH /file.txt HTTP/1.1\nHost: www.example.com\nContent-Type: application/example\nIf-Match: \"e0023aa4e\"\nContent-Length: 100\n\n[description of changes]\n```\n\n<a name=\"DELETE\"></a>\n### DELETE\n\n> 删除文件\n\n\n与 PUT 功能相反，并且同样不带验证机制。\n\n```\nDELETE /file.html HTTP/1.1\n```\n\n<a name=\"OPTIONS\"></a>\n### OPTIONS\n\n> 查询支持的方法\n\n\n查询指定的 URL 能够支持的方法。\n\n会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。\n\n<a name=\"CONNECT\"></a>\n### CONNECT\n\n> 要求在与代理服务器通信时建立隧道\n\n\n使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\n```\nCONNECT www.example.com:443 HTTP/1.1\n```\n\n![](https://cdn.nlark.com/yuque/0/2020/jpeg/407890/1581735085074-18b6e6f8-b427-49f5-acd8-264d4e2c1c67.jpeg#align=left&display=inline&height=145&originHeight=185&originWidth=654&size=0&status=done&style=none&width=511)\n\n<a name=\"TRACE\"></a>\n### TRACE\n\n> 追踪路径\n\n\n服务器会将通信路径返回给客户端。\n\n发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。\n\n通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。\n\n<a name=\"82594747\"></a>\n### Post和get区别\n\n- 作用\n\nGET 用于获取资源，而 POST 用于传输实体主体。<br />\n\n- 参数\n\nGET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。<br />因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87`，而空格会转换为 `%20`。POST 参数支持标准字符集。<br />      \n```bash\nGET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1\n```\n\n```bash\nPOST /test/demo_form.asp HTTP/1.1\nHost: w3schools.com\nname1=value1&name2=value2\n```\n<br />\n\n- 安全\n\n安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。<br />\n<br />GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。<br />\n<br />安全的方法除了 GET 之外还有：HEAD、OPTIONS。<br />不安全的方法除了 POST 之外还有 PUT、DELETE。<br />\n\n- 幂等性\n\n\n\n幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。\n\n所有的安全方法也都是幂等的。\n\n在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。\n\nGET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：\n```\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1Copy to clipboardErrorCopied\n```\n\nPOST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：\n```\nPOST /add_row HTTP/1.1   -> Adds a 1nd row\nPOST /add_row HTTP/1.1   -> Adds a 2nd row\nPOST /add_row HTTP/1.1   -> Adds a 3rd rowCopy to clipboardErrorCopied\n```\n\nDELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：\n```\nDELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists\nDELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted\nDELETE /idX/delete HTTP/1.1   -> Returns 404Copy to clipboardErrorCopied\n```\n<a name=\"IkxAu\"></a>\n## <br />\n\n- 可缓存\n\n如果要对响应进行缓存，需要满足以下条件：\n\n  - 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。\n  - 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。\n  - 响应报文的 Cache-Control 首部字段没有指定不进行缓存。\n\n- XMLHttpRequest\n\n为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：\n> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。\n\n\n  - 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。\n  - 而 GET 方法 Header 和 Data 会一起发送。\n\n\n\n<a name=\"RGl0A\"></a>\n### Post和Put区别\n    有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。\n\n在HTTP中，PUT被定义为**idempotent**的方法，POST则不是，这是一个很重要的区别。\n\n>   “Methods can also have the property of \"idempotence\" in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request.”\n\n上面的话就是说，如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。\n\n举一个简单的例子，假如有一个博客系统提供一个Web API，模式是这样http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。我们应该用PUT方法还是POST方法？取决于这个REST服务的行为是否是idempotent的，假如我们发送两个http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。\n\n也许你会觉得这个两个方法的差别没什么大不了的，用错了也不会有什么问题，但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦。比如，没准Google Crawler也会访问你的服务，如果让一个不是indempotent的服务可以用indempotent的方法访问，那么你服务器的状态可能就会被Crawler修改，这是不应该发生的。\n\n<a name=\"a9ad58d3\"></a>\n## 三、HTTP状态码\n\n服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。\n\n| 状态码 | 类别 | 含义 |\n| --- | --- | --- |\n| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |\n| 2XX | Success（成功状态码） | 请求正常处理完毕 |\n| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |\n| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |\n| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |\n\n\n<a name=\"389ecac2\"></a>\n### 1XX 信息\n\n- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。\n\n<a name=\"03b61604\"></a>\n### 2XX 成功\n\n- **200 OK**\n- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。\n- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。\n\n<a name=\"fd3dcd4f\"></a>\n### 3XX 重定向\n\n- **301 Moved Permanently** ：永久性重定向\n- **302 Found** ：临时性重定向\n- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。\n- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。\n- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。\n- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。\n\n<a name=\"f28d5912\"></a>\n### 4XX 客户端错误\n\n- **400 Bad Request** ：请求报文中存在语法错误。\n- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。\n- **403 Forbidden** ：请求被拒绝。\n- **404 Not Found**\n\n<a name=\"44e70a1a\"></a>\n### 5XX 服务器错误\n\n- **500 Internal Server Error** ：服务器正在执行请求时发生错误。\n- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n<a name=\"d13fa9c9\"></a>\n## 四、HTTP首部\n\n有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。\n\n各种首部字段及其含义如下（不需要全记，仅供查阅）：\n\n<a name=\"ad595596\"></a>\n### 通用首部字段\n| 首部字段名 | 说明 |\n| --- | --- |\n| Cache-Control | 控制缓存的行为 |\n| Connection | 控制不再转发给代理的首部字段、管理持久连接 |\n| Date | 创建报文的日期时间 |\n| Pragma | 报文指令 |\n| Trailer | 报文末端的首部一览 |\n| Transfer-Encoding | 指定报文主体的传输编码方式 |\n| Upgrade | 升级为其他协议 |\n| Via | 代理服务器的相关信息 |\n| Warning | 错误通知 |\n\n\n常用通用首部字段（请求报文与响应报文都会使用的首部字段）\n\n- Date：创建报文时间\n- Connection：连接的管理\n- Cache-Control：缓存的控制\n- Transfer-Encoding：报文主体的传输编码方式\n\n<a name=\"77a3e006\"></a>\n### 请求首部字段\n| 首部字段名 | 说明 |\n| --- | --- |\n| Accept | 用户代理可处理的媒体类型 |\n| Accept-Charset | 优先的字符集 |\n| Accept-Encoding | 优先的内容编码 |\n| Accept-Language | 优先的语言（自然语言） |\n| Authorization | Web 认证信息 |\n| Expect | 期待服务器的特定行为 |\n| From | 用户的电子邮箱地址 |\n| Host | 请求资源所在服务器 |\n| If-Match | 比较实体标记（ETag） |\n| If-Modified-Since | 比较资源的更新时间 |\n| If-None-Match | 比较实体标记（与 If-Match 相反） |\n| If-Range | 资源未更新时发送实体 Byte 的范围请求 |\n| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |\n| Max-Forwards | 最大传输逐跳数 |\n| Proxy-Authorization | 代理服务器要求客户端的认证信息 |\n| Range | 实体的字节范围请求 |\n| Referer | 对请求中 URI 的原始获取方 |\n| TE | 传输编码的优先级 |\n| User-Agent | HTTP 客户端程序的信息 |\n\n\n- **常用请求首部字段（请求报文会使用的首部字段）**\n- <br />\n  - Host：请求资源所在服务器\n  - Accept：可处理的媒体类型\n  - Accept-Charset：可接收的字符集\n  - Accept-Encoding：可接受的内容编码\n  - Accept-Language：可接受的自然语言\n\n<a name=\"b7f3c1e8\"></a>\n### 响应首部字段\n| 首部字段名 | 说明 |\n| --- | --- |\n| Accept-Ranges | 是否接受字节范围请求 |\n| Age | 推算资源创建经过时间 |\n| ETag | 资源的匹配信息 |\n| Location | 令客户端重定向至指定 URI |\n| Proxy-Authenticate | 代理服务器对客户端的认证信息 |\n| Retry-After | 对再次发起请求的时机要求 |\n| Server | HTTP 服务器的安装信息 |\n| Vary | 代理服务器缓存的管理信息 |\n| WWW-Authenticate | 服务器对客户端的认证信息 |\n\n\n- **常用响应首部字段（响应报文会使用的首部字段）**\n- <br />\n  - Accept-Ranges：可接受的字节范围\n  - Location：令客户端重新定向到的URI\n  - Server：HTTP服务器的安装信息\n\n<a name=\"56e4abe9\"></a>\n### 实体首部字段\n| 首部字段名 | 说明 |\n| --- | --- |\n| Allow | 资源可支持的 HTTP 方法 |\n| Content-Encoding | 实体主体适用的编码方式 |\n| Content-Language | 实体主体的自然语言 |\n| Content-Length | 实体主体的大小 |\n| Content-Location | 替代对应资源的 URI |\n| Content-MD5 | 实体主体的报文摘要 |\n| Content-Range | 实体主体的位置范围 |\n| Content-Type | 实体主体的媒体类型 |\n| Expires | 实体主体过期的日期时间 |\n| Last-Modified | 资源的最后修改日期时间 |\n\n\n- **常用实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）**\n- <br />\n  - Allow：资源可支持的HTTP方法\n  - Content-Type：实体主类的类型\n  - Content-Encoding：实体主体适用的编码方式\n  - Content-Language：实体主体的自然语言\n  - Content-Length：实体主体的的字节数\n  - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用\n\n<a name=\"962ac791\"></a>\n## 五、具体应用\n\n<a name=\"d2f1f3cd\"></a>\n### 连接管理\n\n<a name=\"18b6f3fc\"></a>\n#### 1. 短连接与长连接\n\n当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。\n\n长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。\n\n- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；\n- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。\n\n<a name=\"51375e5b\"></a>\n#### 2. 流水线\n\n默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。\n\n流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。\n\n<a name=\"Cookie\"></a>\n### Cookie\n\nHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。\n\nCookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。\n\nCookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。\n\n<a name=\"3a3b1843\"></a>\n#### 1. 用途\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\n<a name=\"e676706c\"></a>\n#### 2. 创建过程\n\n服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。\n\n```\nHTTP/1.0 200 OK\nContent-type: text/html\nSet-Cookie: yummy_cookie=choco\nSet-Cookie: tasty_cookie=strawberry\n\n[page content]\n```\n\n客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。\n\n```\nGET /sample_page.html HTTP/1.1\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry\n```\n\n<a name=\"7bc2b9f0\"></a>\n#### 3. 分类\n\n- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。\n- 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\n```\n\n<a name=\"fcffe399\"></a>\n#### 4. 作用域\n\nDomain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。\n\nPath 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (\"/\") 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：\n\n- /docs\n- /docs/Web/\n- /docs/Web/HTTP\n\n<a name=\"00ad48ff\"></a>\n#### 5. JavaScript\n\n浏览器通过 `document.cookie` 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。\n\n```\ndocument.cookie = \"yummy_cookie=choco\";\ndocument.cookie = \"tasty_cookie=strawberry\";\nconsole.log(document.cookie);\n```\n\n<a name=\"2b699bb6\"></a>\n#### 6. HttpOnly\n\n标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 `document.cookie`API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\n```\n\n<a name=\"4e9d1f2d\"></a>\n#### 7. Secure\n\n标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。\n\n<a name=\"1b52270c\"></a>\n#### 8. Session\n\n除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。\n\nSession 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。\n\n使用 Session 维护用户登录状态的过程如下：\n\n- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；\n- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；\n- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；\n- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。\n\n应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。\n\n<a name=\"371e5cba\"></a>\n#### 9. 浏览器禁用 Cookie\n\n此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。\n\n<a name=\"06323034\"></a>\n#### 10. Cookie 与 Session 选择\n\n- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；\n- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；\n- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。\n\n<a name=\"e80c310e\"></a>\n### 缓存\n\n<a name=\"2d99a8dc\"></a>\n#### 1. 优点\n\n- 缓解服务器压力；\n- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。\n\n<a name=\"888dc13e\"></a>\n#### 2. 实现方法\n\n- 让代理服务器进行缓存；\n- 让客户端浏览器进行缓存。\n\n<a name=\"d705e38a\"></a>\n#### 3. Cache-Control\n\nHTTP/1.1 通过 Cache-Control 首部字段来控制缓存。\n\n**3.1 禁止进行缓存**\n\nno-store 指令规定不能对请求或响应的任何一部分进行缓存。\n\n```\nCache-Control: no-store\n```\n\n**3.2 强制确认缓存**\n\nno-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。\n\n```\nCache-Control: no-cache\n```\n\n**3.3 私有缓存和公共缓存**\n\nprivate 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。\n\n```\nCache-Control: private\n```\n\npublic 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。\n\n```\nCache-Control: public\n```\n\n**3.4 缓存过期机制**\n\nmax-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。\n\nmax-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。\n\n```\nCache-Control: max-age=31536000\n```\n\nExpires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。\n\n```\nExpires: Wed, 04 Jul 2012 08:26:05 GMT\n```\n\n- 在 HTTP/1.1 中，会优先处理 max-age 指令；\n- 在 HTTP/1.0 中，max-age 指令会被忽略掉。\n\n<a name=\"ab1ef9ae\"></a>\n#### 4. 缓存验证\n\n需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。\n\n```\nETag: \"82e22293907ce725faf67773957acd12\"\n```\n\n可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。\n\n```\nIf-None-Match: \"82e22293907ce725faf67773957acd12\"\n```\n\nLast-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。\n\n```\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT\nIf-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT\n```\n\n<a name=\"f16ab050\"></a>\n### 内容协商\n\n通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。\n\n<a name=\"5130c3b5\"></a>\n#### 1. 类型\n\n**1.1 服务端驱动型**\n\n客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。\n\n它存在以下问题：\n\n- 服务器很难知道客户端浏览器的全部信息；\n- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；\n- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。\n\n**1.2 代理驱动型**\n\n服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。\n\n<a name=\"12b1a2d0\"></a>\n#### 2. Vary\n\n```\nVary: Accept-Language\n```\n\n在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。\n\n例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。\n\n<a name=\"4e695651\"></a>\n### 内容编码\n\n内容编码将实体主体进行压缩，从而减少传输的数据量。\n\n常用的内容编码有：gzip、compress、deflate、identity。\n\n浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。\n\n<a name=\"16fa3925\"></a>\n### 范围请求\n\n如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。\n\n<a name=\"aef2915d\"></a>\n#### 1. Range\n\n在请求报文中添加 Range 首部字段指定请求的范围。\n\n```\nGET /z4d4kWk.jpg HTTP/1.1\nHost: i.imgur.com\nRange: bytes=0-1023\n```\n\n请求成功的话服务器返回的响应包含 206 Partial Content 状态码。\n\n```\nHTTP/1.1 206 Partial Content\nContent-Range: bytes 0-1023/146515\nContent-Length: 1024\n...\n(binary content)\n```\n\n<a name=\"56167de1\"></a>\n#### 2. Accept-Ranges\n\n响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。\n\n```\nAccept-Ranges: bytes\n```\n\n<a name=\"9ff66133\"></a>\n#### 3. 响应状态码\n\n- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。\n- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。\n- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。\n\n<a name=\"f7f86bef\"></a>\n### 分块传输编码\n\nChunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。\n\n<a name=\"ef467585\"></a>\n### 多部分对象集合\n\n一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。\n\n例如，上传多个表单时可以使用如下方式：\n\n```\nContent-Type: multipart/form-data; boundary=AaB03x\n\n--AaB03x\nContent-Disposition: form-data; name=\"submit-name\"\n\nLarry\n--AaB03x\nContent-Disposition: form-data; name=\"files\"; filename=\"file1.txt\"\nContent-Type: text/plain\n\n... contents of file1.txt ...\n--AaB03x--\n```\n\n<a name=\"284d8e27\"></a>\n### 虚拟主机\n\nHTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。\n\n<a name=\"e3d7b99d\"></a>\n### 通信数据转发\n\n<a name=\"102bf5e7\"></a>\n#### 1. 代理\n\n代理服务器接受客户端的请求，并且转发给其它服务器。\n\n使用代理的主要目的是：\n\n- 缓存\n- 负载均衡\n- 网络访问控制\n- 访问日志记录\n\n代理服务器分为正向代理和反向代理两种：\n\n- 用户察觉得到正向代理的存在。\n\n![](https://cdn.nlark.com/yuque/0/2020/png/407890/1581737974328-dcbda776-eca3-4f19-9e61-125b07288ef5.png#align=left&display=inline&height=128&originHeight=170&originWidth=527&size=0&status=done&style=none&width=397)\n\n- 而反向代理一般位于内部网络中，用户察觉不到。\n\n![](https://cdn.nlark.com/yuque/0/2020/png/407890/1581737986133-917b90da-f44d-495c-b4ba-ecefa54e3e5c.png#align=left&display=inline&height=133&originHeight=175&originWidth=467&size=0&status=done&style=none&width=356)\n\n<a name=\"8ce89c89\"></a>\n#### 2. 网关\n\n与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。\n\n<a name=\"193a6fc3\"></a>\n#### 3. 隧道\n\n使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。\n\n<a name=\"wrWpw\"></a>\n## 六、重定向\n<a name=\"As8HU\"></a>\n### 什么是重定向\nURL 重定向，也称为 URL 转发，是一种当实际资源，如单个页面、表单或者整个 Web 应用被迁移到新的 URL 下的时候，保持（原有）链接可用的技术。HTTP 协议提供了一种特殊形式的响应—— HTTP 重定向（HTTP redirects）来执行此类操作，该操作可以应用于多种多样的目标：网站维护期间的临时跳转，网站架构改变后为了保持外部链接继续可用的永久重定向，上传文件时的表示进度的页面，等等。\n\n<a name=\"jqmq4\"></a>\n### 永久重定向和临时重定向\n302 重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回 302 代码，搜索引擎认为新的网址只是暂时的。换句话说，已移动的资源对应的 URI 将来还有可能会改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI 。<br />301 重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。\n>   当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。\n>   301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。\n\n\n\n<a name=\"pdqxw\"></a>\n### 重定向和转发\n**深入（分析理解）**\n\n- 转发过程\n\n客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的student_list.jsp,整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，因此servlet和jsp共享的是同一个request，在servlet里面放的所有东西，在student_list中都能取出来，因此，student_list能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端。整个过程是一个请求，一个响应。\n\n- 重定向过程\n\n客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端受到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。\n\n**浅出（表象）**\n\n- 转发\n\n当用RequestDispatcher请求转发后，地址栏为http://localhost:8080/test/TestServlet<br />这真好应正了上面的分析，我们起初请求的就一个servlet，至于你服务器端怎么转，流程怎么样的，我客户端根本就不知道，我发了请求后我就等着响应，那你服务器那边愿意怎么转就怎么转，我客户端不关心也没法知道，所以当服务器端转发到jsp后，它把结果返回给客户端，客户端根本就不知道你这个结果是我真正访问的servlet产生的，还是由servlet转发后下一个组件产生的。\n\n- 重定向\n\n当用sendRedirect重定向后，地址栏为http://localhost:8080/test/student_list.jsp<br />因为这个时候，客户端已经知道了他第二次请求的是student_list.jsp，服务器已经告诉客户端要去访问student_list.jsp了，所以地址栏里会显示想要访问的结果。\n\n<a name=\"1573c74e\"></a>\n## 面试\n\n- 各种协议与HTTP协议之间的关系<br />\n<br />一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。\n<br />图片来源：《图解HTTP》\n<br />\n\n\n\n- HTTP长连接,短连接<br />\n\n在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。\n\n而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：\n\n```\nConnection:keep-alive\n```\n\n在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\n\n**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**\n\n- HTTP是不保存状态的协议,如何保存用户状态?<br />\n\nHTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。\n\n在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。\n\n**Cookie 被禁用怎么办?**\n\n最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。\n\n[![](https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67#align=left&display=inline&height=309&originHeight=309&originWidth=859&status=done&style=none&width=859)](https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67)\n\n- Cookie的作用是什么?和Session有什么区别？<br />\n\nCookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。\n\n**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。\n\nCookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。\n\nCookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。\n\n- URI和URL的区别是什么?<br />\n  - URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\n  - URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\n\nURI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\n\n<a name=\"d17a0f0b\"></a>\n## 参考\n\n- https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#五具体应用\n- [https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483733&idx=2&sn=93b359af4397cd4afa791fdb5f51f0b5&chksm=ebd74054dca0c942be5180cdf0f460ed7f534ca51230147fe0081df15adac76dac9e61d97761&scene=21#wechat_redirect](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483733&idx=2&sn=93b359af4397cd4afa791fdb5f51f0b5&chksm=ebd74054dca0c942be5180cdf0f460ed7f534ca51230147fe0081df15adac76dac9e61d97761&scene=21#wechat_redirect)\n- https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/计算机网络.md#七-各种协议与http协议之间的关系\n', '<h1 id=\"http\">HTTP</h1>\n<p><a name=\"1a8d8590\"></a></p>\n<h2 id=\"一、基础概念\">一、基础概念</h2>\n<p><a name=\"c42ae579\"></a></p>\n<h3 id=\"什么是http\">什么是HTTP</h3>\n<p>HTTP学名叫做超文本传输协议，是一个网络协议。</p>\n<p>是专门用来帮你传输诸如 HTML 的超媒体文档等 Web 内容滴。因为 HTML 本身就是超文本标记语言，HTML 中不仅有文本还有图片、音视频等内容，所以用来传输它的协议当然就叫超文本传输协议了</p>\n<p><a name=\"1cc45ab7\"></a></p>\n<h3 id=\"http的基本性质\">HTTP的基本性质</h3>\n<p>总述：HTTP是简单的、可扩展、无状态的</p>\n<p><strong>HTTP 是简单的</strong></p>\n<p>即便在HTTP/2中把HTTP消息封装到了frames中，HTTP大体上还是被设计成可读的而且简单的。HTTP的消息能够让人读懂且明白它的意思，还允许简单的测试，放低了门槛，更有利于新来者了解。</p>\n<p><strong>HTTP 是可扩展的</strong></p>\n<p>在HTTP/1中就出现了, HTTP headers 让协议扩展变得非常容易。只要服务端和客户端在新的headers上语义达成一致，新的功能就可以轻松地被加进来。</p>\n<p><strong>HTTP 是无状态，有会话的</strong></p>\n<p>HTTP是无状态的：在同一个连接中，两个成功执行的请求之间是没有关系的。这就带来了一个问题，用户没办法在一个网站进行连续的交互，比如在一个电商网站里，用户把某个商品加入了购物车中，换了一个页面后再次添加商品，两次添加商品的请求没有联系，浏览器无法知道最终用户都选择了哪些商品。而用HTTP的头部扩展，<strong>HTTP Cookies就可以解决这个问题</strong>（将在后面介绍）。把Cookies添加到头部中，创建一个会话来让每次请求都能共享相同的上下文信息，相同的状态。<strong>而HTTP的核心是无状态的，cookies的使用可以创建有状态的会话。</strong></p>\n<p><a name=\"6f0533b7\"></a></p>\n<h3 id=\"http-协议如何使用-tcp-连接？\">HTTP 协议如何使用 TCP 连接？</h3>\n<p>HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”）</p>\n<p>假设有一个网页，里面包含好多图片，还包含好多 外部的 CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对 每一个 外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）<br />相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。</p>\n<p>在 HTTP 1.0 版本，默认使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）.</p>\n<p>到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，默认采用的是“Keep-Alive”的方式。</p>\n<p><a name=\"e364a069\"></a></p>\n<h3 id=\"http10、11、20之间的区别，不同版本的特点\">HTTP1.0、1.1、2.0之间的区别，不同版本的特点</h3>\n<p>详细的解释在HTTPS那篇文章。</p>\n<ul>\n<li>HTTP1.1与1.0之间的区别:<ol>\n<li>HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。而1.0不支持长连接。客户端和服务器每进行一次HTTP操作，就建立一次连接。</li>\n<li>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>\n<li>Host头处理：1.0请求的url并没有传递主机名(服务器与IP地址绑定)，1.1请求和响应都支持Host头域(虚拟主机共享IP地址)</li>\n<li>1.1新增24个错误状态响应码。409：请求的资源和资源的当前状态冲突，410：服务器资源永久性删除。</li>\n<li>带宽优化以及网络连接的使用：1.1允许只请求资源的某个部分.</li>\n</ol>\n</li>\n<li>HTTP2.0和HTTP1.X相比的新特性<ol>\n<li>新的二进制格式：1.x的解析是基于文本的，而2.0的协议解析是采用二进制格式。</li>\n<li>多路复用，具体解释在HTTPS那篇</li>\n<li>header压缩。</li>\n<li>服务端推送。</li>\n</ol>\n</li>\n</ul>\n<p><a name=\"URI\"></a></p>\n<h3 id=\"uri\">URI</h3>\n<p>URI 包含 URL 和 URN。</p>\n<p><a name=\"6b954c92\"></a></p>\n<h3 id=\"请求和响应报文\">请求和响应报文</h3>\n<p><a name=\"324d4210\"></a></p>\n<h4 id=\"1-请求报文\">1. 请求报文</h4>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/407890/1581734448103-68d310ef-be81-4fb0-b6e5-f2d7cad3e60c.png#align=left&display=inline&height=131&originHeight=221&originWidth=656&size=0&status=done&style=none&width=388\" alt=\"\"></p>\n<p><a name=\"97fc6632\"></a></p>\n<h4 id=\"2-响应报文\">2. 响应报文</h4>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/407890/1581734462293-e998f98a-71a3-495c-bb2b-5308ab7ea030.png#align=left&display=inline&height=148&originHeight=267&originWidth=704&size=0&status=done&style=none&width=390\" alt=\"\"></p>\n<p><a name=\"c8c706cc\"></a></p>\n<h2 id=\"二、http方法\">二、HTTP方法</h2>\n<p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>\n<p><a name=\"GET\"></a></p>\n<h3 id=\"get\">GET</h3>\n<blockquote>\n<p>获取资源</p>\n</blockquote>\n<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>\n<p><a name=\"HEAD\"></a></p>\n<h3 id=\"head\">HEAD</h3>\n<blockquote>\n<p>获取报文首部</p>\n</blockquote>\n<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>\n<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>\n<p><a name=\"POST\"></a></p>\n<h3 id=\"post\">POST</h3>\n<blockquote>\n<p>传输实体主体</p>\n</blockquote>\n<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>\n<p>更多 POST 与 GET 的比较请见第九章。</p>\n<p><a name=\"PUT\"></a></p>\n<h3 id=\"put\">PUT</h3>\n<blockquote>\n<p>上传文件</p>\n</blockquote>\n<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>\n<pre><code>PUT /new.html HTTP/1.1\nHost: example.com\nContent-type: text/html\nContent-length: 16\n\n&lt;p&gt;New File&lt;/p&gt;</code></pre><p><a name=\"PATCH\"></a></p>\n<h3 id=\"patch\">PATCH</h3>\n<blockquote>\n<p>对资源进行部分修改</p>\n</blockquote>\n<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>\n<pre><code>PATCH /file.txt HTTP/1.1\nHost: www.example.com\nContent-Type: application/example\nIf-Match: &quot;e0023aa4e&quot;\nContent-Length: 100\n\n[description of changes]</code></pre><p><a name=\"DELETE\"></a></p>\n<h3 id=\"delete\">DELETE</h3>\n<blockquote>\n<p>删除文件</p>\n</blockquote>\n<p>与 PUT 功能相反，并且同样不带验证机制。</p>\n<pre><code>DELETE /file.html HTTP/1.1</code></pre><p><a name=\"OPTIONS\"></a></p>\n<h3 id=\"options\">OPTIONS</h3>\n<blockquote>\n<p>查询支持的方法</p>\n</blockquote>\n<p>查询指定的 URL 能够支持的方法。</p>\n<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>\n<p><a name=\"CONNECT\"></a></p>\n<h3 id=\"connect\">CONNECT</h3>\n<blockquote>\n<p>要求在与代理服务器通信时建立隧道</p>\n</blockquote>\n<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<pre><code>CONNECT www.example.com:443 HTTP/1.1</code></pre><p><img src=\"https://cdn.nlark.com/yuque/0/2020/jpeg/407890/1581735085074-18b6e6f8-b427-49f5-acd8-264d4e2c1c67.jpeg#align=left&display=inline&height=145&originHeight=185&originWidth=654&size=0&status=done&style=none&width=511\" alt=\"\"></p>\n<p><a name=\"TRACE\"></a></p>\n<h3 id=\"trace\">TRACE</h3>\n<blockquote>\n<p>追踪路径</p>\n</blockquote>\n<p>服务器会将通信路径返回给客户端。</p>\n<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>\n<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>\n<p><a name=\"82594747\"></a></p>\n<h3 id=\"post和get区别\">Post和get区别</h3>\n<ul>\n<li>作用</li>\n</ul>\n<p>GET 用于获取资源，而 POST 用于传输实体主体。<br /></p>\n<ul>\n<li>参数</li>\n</ul>\n<p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。<br />因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。<br />      </p>\n<pre><code class=\"language-bash\">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</code></pre>\n<pre><code class=\"language-bash\">POST /test/demo_form.asp HTTP/1.1\nHost: w3schools.com\nname1=value1&amp;name2=value2</code></pre>\n<br />\n\n<ul>\n<li>安全</li>\n</ul>\n<p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。<br />\n<br />GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。<br />\n<br />安全的方法除了 GET 之外还有：HEAD、OPTIONS。<br />不安全的方法除了 POST 之外还有 PUT、DELETE。<br /></p>\n<ul>\n<li>幂等性</li>\n</ul>\n<p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>\n<p>所有的安全方法也都是幂等的。</p>\n<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>\n<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>\n<pre><code>GET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1Copy to clipboardErrorCopied</code></pre><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>\n<pre><code>POST /add_row HTTP/1.1   -&gt; Adds a 1nd row\nPOST /add_row HTTP/1.1   -&gt; Adds a 2nd row\nPOST /add_row HTTP/1.1   -&gt; Adds a 3rd rowCopy to clipboardErrorCopied</code></pre><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p>\n<pre><code>DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists\nDELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted\nDELETE /idX/delete HTTP/1.1   -&gt; Returns 404Copy to clipboardErrorCopied</code></pre><p><a name=\"IkxAu\"></a></p>\n<h2 id=\"br-\"><br /></h2>\n<ul>\n<li>可缓存</li>\n</ul>\n<p>如果要对响应进行缓存，需要满足以下条件：</p>\n<ul>\n<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>\n<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>\n<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>\n</ul>\n<ul>\n<li>XMLHttpRequest</li>\n</ul>\n<p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>\n<blockquote>\n<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>\n</blockquote>\n<ul>\n<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>\n<li>而 GET 方法 Header 和 Data 会一起发送。</li>\n</ul>\n<p><a name=\"RGl0A\"></a></p>\n<h3 id=\"post和put区别\">Post和Put区别</h3>\n<p>    有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。</p>\n<p>在HTTP中，PUT被定义为<strong>idempotent</strong>的方法，POST则不是，这是一个很重要的区别。</p>\n<blockquote>\n<p>  “Methods can also have the property of &quot;idempotence&quot; in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.”</p>\n</blockquote>\n<p>上面的话就是说，如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。</p>\n<p>举一个简单的例子，假如有一个博客系统提供一个Web API，模式是这样<a href=\"http://superblogging/blogs/post/%7Bblog-name%7D%EF%BC%8C%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E5%B0%86%7Bblog-name%7D%E6%9B%BF%E6%8D%A2%E4%B8%BA%E6%88%91%E4%BB%AC%E7%9A%84blog%E5%90%8D%E5%AD%97%EF%BC%8C%E5%BE%80%E8%BF%99%E4%B8%AAURI%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AAHTTP\">http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP</a> PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。我们应该用PUT方法还是POST方法？取决于这个REST服务的行为是否是idempotent的，假如我们发送两个<a href=\"http://superblogging/blogs/post/Sample%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%BA%A7%E7%94%9F%E4%BA%86%E4%B8%A4%E4%B8%AA%E5%8D%9A%E5%AE%A2%E5%B8%96%E5%AD%90%EF%BC%8C%E9%82%A3%E5%B0%B1%E8%AF%B4%E6%98%8E%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E4%B8%8D%E6%98%AFidempotent%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A4%9A%E6%AC%A1%E4%BD%BF%E7%94%A8%E4%BA%A7%E7%94%9F%E4%BA%86%E5%89%AF%E4%BD%9C%E7%94%A8%E4%BA%86%E5%98%9B%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%90%8E%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%8A%8A%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E8%A6%86%E7%9B%96%E6%8E%89%E4%BA%86%EF%BC%8C%E9%82%A3%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%B0%B1%E6%98%AFidempotent%E7%9A%84%E3%80%82%E5%89%8D%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8POST%E6%96%B9%E6%B3%95%EF%BC%8C%E5%90%8E%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8PUT%E6%96%B9%E6%B3%95%E3%80%82\">http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。</a></p>\n<p>也许你会觉得这个两个方法的差别没什么大不了的，用错了也不会有什么问题，但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦。比如，没准Google Crawler也会访问你的服务，如果让一个不是indempotent的服务可以用indempotent的方法访问，那么你服务器的状态可能就会被Crawler修改，这是不应该发生的。</p>\n<p><a name=\"a9ad58d3\"></a></p>\n<h2 id=\"三、http状态码\">三、HTTP状态码</h2>\n<p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>类别</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>Informational（信息性状态码）</td>\n<td>接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码）</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码）</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error（客户端错误状态码）</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务器错误状态码）</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<p><a name=\"389ecac2\"></a></p>\n<h3 id=\"1xx-信息\">1XX 信息</h3>\n<ul>\n<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>\n</ul>\n<p><a name=\"03b61604\"></a></p>\n<h3 id=\"2xx-成功\">2XX 成功</h3>\n<ul>\n<li><strong>200 OK</strong></li>\n<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>\n<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>\n</ul>\n<p><a name=\"fd3dcd4f\"></a></p>\n<h3 id=\"3xx-重定向\">3XX 重定向</h3>\n<ul>\n<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>\n<li><strong>302 Found</strong> ：临时性重定向</li>\n<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>\n<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>\n<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>\n<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>\n</ul>\n<p><a name=\"f28d5912\"></a></p>\n<h3 id=\"4xx-客户端错误\">4XX 客户端错误</h3>\n<ul>\n<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>\n<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>\n<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>\n<li><strong>404 Not Found</strong></li>\n</ul>\n<p><a name=\"44e70a1a\"></a></p>\n<h3 id=\"5xx-服务器错误\">5XX 服务器错误</h3>\n<ul>\n<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>\n<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>\n</ul>\n<p><a name=\"d13fa9c9\"></a></p>\n<h2 id=\"四、http首部\">四、HTTP首部</h2>\n<p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>\n<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>\n<p><a name=\"ad595596\"></a></p>\n<h3 id=\"通用首部字段\">通用首部字段</h3>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache-Control</td>\n<td>控制缓存的行为</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>控制不再转发给代理的首部字段、管理持久连接</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>创建报文的日期时间</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>报文指令</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>报文末端的首部一览</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>指定报文主体的传输编码方式</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>升级为其他协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>代理服务器的相关信息</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>错误通知</td>\n</tr>\n</tbody></table>\n<p>常用通用首部字段（请求报文与响应报文都会使用的首部字段）</p>\n<ul>\n<li>Date：创建报文时间</li>\n<li>Connection：连接的管理</li>\n<li>Cache-Control：缓存的控制</li>\n<li>Transfer-Encoding：报文主体的传输编码方式</li>\n</ul>\n<p><a name=\"77a3e006\"></a></p>\n<h3 id=\"请求首部字段\">请求首部字段</h3>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>优先的语言（自然语言）</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web 认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待服务器的特定行为</td>\n</tr>\n<tr>\n<td>From</td>\n<td>用户的电子邮箱地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记（ETag）</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记（与 If-Match 相反）</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源未更新时发送实体 Byte 的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证信息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>对请求中 URI 的原始获取方</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP 客户端程序的信息</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>常用请求首部字段（请求报文会使用的首部字段）</strong></li>\n<li><br />\n- Host：请求资源所在服务器\n- Accept：可处理的媒体类型\n- Accept-Charset：可接收的字符集\n- Accept-Encoding：可接受的内容编码\n- Accept-Language：可接受的自然语言\n\n</li>\n</ul>\n<p><a name=\"b7f3c1e8\"></a></p>\n<h3 id=\"响应首部字段\">响应首部字段</h3>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept-Ranges</td>\n<td>是否接受字节范围请求</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>推算资源创建经过时间</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>资源的匹配信息</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>令客户端重定向至指定 URI</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>代理服务器对客户端的认证信息</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>对再次发起请求的时机要求</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>HTTP 服务器的安装信息</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器缓存的管理信息</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>服务器对客户端的认证信息</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>常用响应首部字段（响应报文会使用的首部字段）</strong></li>\n<li><br />\n- Accept-Ranges：可接受的字节范围\n- Location：令客户端重新定向到的URI\n- Server：HTTP服务器的安装信息\n\n</li>\n</ul>\n<p><a name=\"56e4abe9\"></a></p>\n<h3 id=\"实体首部字段\">实体首部字段</h3>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allow</td>\n<td>资源可支持的 HTTP 方法</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>实体主体适用的编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>实体主体的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>实体主体的大小</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>替代对应资源的 URI</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>实体主体的报文摘要</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>实体主体的位置范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>实体主体的媒体类型</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体主体过期的日期时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源的最后修改日期时间</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>常用实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong></li>\n<li><br />\n- Allow：资源可支持的HTTP方法\n- Content-Type：实体主类的类型\n- Content-Encoding：实体主体适用的编码方式\n- Content-Language：实体主体的自然语言\n- Content-Length：实体主体的的字节数\n- Content-Range：实体主体的位置范围，一般用于发出部分请求时使用\n\n</li>\n</ul>\n<p><a name=\"962ac791\"></a></p>\n<h2 id=\"五、具体应用\">五、具体应用</h2>\n<p><a name=\"d2f1f3cd\"></a></p>\n<h3 id=\"连接管理\">连接管理</h3>\n<p><a name=\"18b6f3fc\"></a></p>\n<h4 id=\"1-短连接与长连接\">1. 短连接与长连接</h4>\n<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>\n<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>\n<ul>\n<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>\n<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>\n</ul>\n<p><a name=\"51375e5b\"></a></p>\n<h4 id=\"2-流水线\">2. 流水线</h4>\n<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>\n<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>\n<p><a name=\"Cookie\"></a></p>\n<h3 id=\"cookie\">Cookie</h3>\n<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>\n<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>\n<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>\n<p><a name=\"3a3b1843\"></a></p>\n<h4 id=\"1-用途\">1. 用途</h4>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<p><a name=\"e676706c\"></a></p>\n<h4 id=\"2-创建过程\">2. 创建过程</h4>\n<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>\n<pre><code>HTTP/1.0 200 OK\nContent-type: text/html\nSet-Cookie: yummy_cookie=choco\nSet-Cookie: tasty_cookie=strawberry\n\n[page content]</code></pre><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>\n<pre><code>GET /sample_page.html HTTP/1.1\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry</code></pre><p><a name=\"7bc2b9f0\"></a></p>\n<h4 id=\"3-分类\">3. 分类</h4>\n<ul>\n<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>\n<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>\n</ul>\n<pre><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</code></pre><p><a name=\"fcffe399\"></a></p>\n<h4 id=\"4-作用域\">4. 作用域</h4>\n<p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>\n<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>\n<ul>\n<li>/docs</li>\n<li>/docs/Web/</li>\n<li>/docs/Web/HTTP</li>\n</ul>\n<p><a name=\"00ad48ff\"></a></p>\n<h4 id=\"5-javascript\">5. JavaScript</h4>\n<p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>\n<pre><code>document.cookie = &quot;yummy_cookie=choco&quot;;\ndocument.cookie = &quot;tasty_cookie=strawberry&quot;;\nconsole.log(document.cookie);</code></pre><p><a name=\"2b699bb6\"></a></p>\n<h4 id=\"6-httponly\">6. HttpOnly</h4>\n<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code>API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>\n<pre><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</code></pre><p><a name=\"4e9d1f2d\"></a></p>\n<h4 id=\"7-secure\">7. Secure</h4>\n<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>\n<p><a name=\"1b52270c\"></a></p>\n<h4 id=\"8-session\">8. Session</h4>\n<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>\n<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>\n<p>使用 Session 维护用户登录状态的过程如下：</p>\n<ul>\n<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>\n<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>\n<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>\n<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>\n</ul>\n<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>\n<p><a name=\"371e5cba\"></a></p>\n<h4 id=\"9-浏览器禁用-cookie\">9. 浏览器禁用 Cookie</h4>\n<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>\n<p><a name=\"06323034\"></a></p>\n<h4 id=\"10-cookie-与-session-选择\">10. Cookie 与 Session 选择</h4>\n<ul>\n<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>\n<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>\n<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>\n</ul>\n<p><a name=\"e80c310e\"></a></p>\n<h3 id=\"缓存\">缓存</h3>\n<p><a name=\"2d99a8dc\"></a></p>\n<h4 id=\"1-优点\">1. 优点</h4>\n<ul>\n<li>缓解服务器压力；</li>\n<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>\n</ul>\n<p><a name=\"888dc13e\"></a></p>\n<h4 id=\"2-实现方法\">2. 实现方法</h4>\n<ul>\n<li>让代理服务器进行缓存；</li>\n<li>让客户端浏览器进行缓存。</li>\n</ul>\n<p><a name=\"d705e38a\"></a></p>\n<h4 id=\"3-cache-control\">3. Cache-Control</h4>\n<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>\n<p><strong>3.1 禁止进行缓存</strong></p>\n<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>\n<pre><code>Cache-Control: no-store</code></pre><p><strong>3.2 强制确认缓存</strong></p>\n<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>\n<pre><code>Cache-Control: no-cache</code></pre><p><strong>3.3 私有缓存和公共缓存</strong></p>\n<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>\n<pre><code>Cache-Control: private</code></pre><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>\n<pre><code>Cache-Control: public</code></pre><p><strong>3.4 缓存过期机制</strong></p>\n<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>\n<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>\n<pre><code>Cache-Control: max-age=31536000</code></pre><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>\n<pre><code>Expires: Wed, 04 Jul 2012 08:26:05 GMT</code></pre><ul>\n<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>\n<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>\n</ul>\n<p><a name=\"ab1ef9ae\"></a></p>\n<h4 id=\"4-缓存验证\">4. 缓存验证</h4>\n<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>\n<pre><code>ETag: &quot;82e22293907ce725faf67773957acd12&quot;</code></pre><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>\n<pre><code>If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</code></pre><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>\n<pre><code>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT\nIf-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</code></pre><p><a name=\"f16ab050\"></a></p>\n<h3 id=\"内容协商\">内容协商</h3>\n<p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>\n<p><a name=\"5130c3b5\"></a></p>\n<h4 id=\"1-类型\">1. 类型</h4>\n<p><strong>1.1 服务端驱动型</strong></p>\n<p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p>\n<p>它存在以下问题：</p>\n<ul>\n<li>服务器很难知道客户端浏览器的全部信息；</li>\n<li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li>\n<li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li>\n</ul>\n<p><strong>1.2 代理驱动型</strong></p>\n<p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p>\n<p><a name=\"12b1a2d0\"></a></p>\n<h4 id=\"2-vary\">2. Vary</h4>\n<pre><code>Vary: Accept-Language</code></pre><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p>\n<p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p>\n<p><a name=\"4e695651\"></a></p>\n<h3 id=\"内容编码\">内容编码</h3>\n<p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p>\n<p>常用的内容编码有：gzip、compress、deflate、identity。</p>\n<p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p>\n<p><a name=\"16fa3925\"></a></p>\n<h3 id=\"范围请求\">范围请求</h3>\n<p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p>\n<p><a name=\"aef2915d\"></a></p>\n<h4 id=\"1-range\">1. Range</h4>\n<p>在请求报文中添加 Range 首部字段指定请求的范围。</p>\n<pre><code>GET /z4d4kWk.jpg HTTP/1.1\nHost: i.imgur.com\nRange: bytes=0-1023</code></pre><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p>\n<pre><code>HTTP/1.1 206 Partial Content\nContent-Range: bytes 0-1023/146515\nContent-Length: 1024\n...\n(binary content)</code></pre><p><a name=\"56167de1\"></a></p>\n<h4 id=\"2-accept-ranges\">2. Accept-Ranges</h4>\n<p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p>\n<pre><code>Accept-Ranges: bytes</code></pre><p><a name=\"9ff66133\"></a></p>\n<h4 id=\"3-响应状态码\">3. 响应状态码</h4>\n<ul>\n<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>\n<li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>\n<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>\n</ul>\n<p><a name=\"f7f86bef\"></a></p>\n<h3 id=\"分块传输编码\">分块传输编码</h3>\n<p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p>\n<p><a name=\"ef467585\"></a></p>\n<h3 id=\"多部分对象集合\">多部分对象集合</h3>\n<p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p>\n<p>例如，上传多个表单时可以使用如下方式：</p>\n<pre><code>Content-Type: multipart/form-data; boundary=AaB03x\n\n--AaB03x\nContent-Disposition: form-data; name=&quot;submit-name&quot;\n\nLarry\n--AaB03x\nContent-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;\nContent-Type: text/plain\n\n... contents of file1.txt ...\n--AaB03x--</code></pre><p><a name=\"284d8e27\"></a></p>\n<h3 id=\"虚拟主机\">虚拟主机</h3>\n<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>\n<p><a name=\"e3d7b99d\"></a></p>\n<h3 id=\"通信数据转发\">通信数据转发</h3>\n<p><a name=\"102bf5e7\"></a></p>\n<h4 id=\"1-代理\">1. 代理</h4>\n<p>代理服务器接受客户端的请求，并且转发给其它服务器。</p>\n<p>使用代理的主要目的是：</p>\n<ul>\n<li>缓存</li>\n<li>负载均衡</li>\n<li>网络访问控制</li>\n<li>访问日志记录</li>\n</ul>\n<p>代理服务器分为正向代理和反向代理两种：</p>\n<ul>\n<li>用户察觉得到正向代理的存在。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/407890/1581737974328-dcbda776-eca3-4f19-9e61-125b07288ef5.png#align=left&display=inline&height=128&originHeight=170&originWidth=527&size=0&status=done&style=none&width=397\" alt=\"\"></p>\n<ul>\n<li>而反向代理一般位于内部网络中，用户察觉不到。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/407890/1581737986133-917b90da-f44d-495c-b4ba-ecefa54e3e5c.png#align=left&display=inline&height=133&originHeight=175&originWidth=467&size=0&status=done&style=none&width=356\" alt=\"\"></p>\n<p><a name=\"8ce89c89\"></a></p>\n<h4 id=\"2-网关\">2. 网关</h4>\n<p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p>\n<p><a name=\"193a6fc3\"></a></p>\n<h4 id=\"3-隧道\">3. 隧道</h4>\n<p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>\n<p><a name=\"wrWpw\"></a></p>\n<h2 id=\"六、重定向\">六、重定向</h2>\n<p><a name=\"As8HU\"></a></p>\n<h3 id=\"什么是重定向\">什么是重定向</h3>\n<p>URL 重定向，也称为 URL 转发，是一种当实际资源，如单个页面、表单或者整个 Web 应用被迁移到新的 URL 下的时候，保持（原有）链接可用的技术。HTTP 协议提供了一种特殊形式的响应—— HTTP 重定向（HTTP redirects）来执行此类操作，该操作可以应用于多种多样的目标：网站维护期间的临时跳转，网站架构改变后为了保持外部链接继续可用的永久重定向，上传文件时的表示进度的页面，等等。</p>\n<p><a name=\"jqmq4\"></a></p>\n<h3 id=\"永久重定向和临时重定向\">永久重定向和临时重定向</h3>\n<p>302 重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回 302 代码，搜索引擎认为新的网址只是暂时的。换句话说，已移动的资源对应的 URI 将来还有可能会改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI 。<br />301 重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p>\n<blockquote>\n<p>  当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。\n  301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。</p>\n</blockquote>\n<p><a name=\"pdqxw\"></a></p>\n<h3 id=\"重定向和转发\">重定向和转发</h3>\n<p><strong>深入（分析理解）</strong></p>\n<ul>\n<li>转发过程</li>\n</ul>\n<p>客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的student_list.jsp,整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，因此servlet和jsp共享的是同一个request，在servlet里面放的所有东西，在student_list中都能取出来，因此，student_list能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端。整个过程是一个请求，一个响应。</p>\n<ul>\n<li>重定向过程</li>\n</ul>\n<p>客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端受到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。</p>\n<p><strong>浅出（表象）</strong></p>\n<ul>\n<li>转发</li>\n</ul>\n<p>当用RequestDispatcher请求转发后，地址栏为<a href=\"http://localhost:8080/test/TestServlet\">http://localhost:8080/test/TestServlet</a><br />这真好应正了上面的分析，我们起初请求的就一个servlet，至于你服务器端怎么转，流程怎么样的，我客户端根本就不知道，我发了请求后我就等着响应，那你服务器那边愿意怎么转就怎么转，我客户端不关心也没法知道，所以当服务器端转发到jsp后，它把结果返回给客户端，客户端根本就不知道你这个结果是我真正访问的servlet产生的，还是由servlet转发后下一个组件产生的。</p>\n<ul>\n<li>重定向</li>\n</ul>\n<p>当用sendRedirect重定向后，地址栏为<a href=\"http://localhost:8080/test/student_list.jsp\">http://localhost:8080/test/student_list.jsp</a><br />因为这个时候，客户端已经知道了他第二次请求的是student_list.jsp，服务器已经告诉客户端要去访问student_list.jsp了，所以地址栏里会显示想要访问的结果。</p>\n<p><a name=\"1573c74e\"></a></p>\n<h2 id=\"面试\">面试</h2>\n<ul>\n<li>各种协议与HTTP协议之间的关系<br />\n<br />一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。\n<br />图片来源：《图解HTTP》<br />\n\n\n\n</li>\n</ul>\n<ul>\n<li>HTTP长连接,短连接<br /></li>\n</ul>\n<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>\n<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>\n<pre><code>Connection:keep-alive</code></pre><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>\n<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>\n<ul>\n<li>HTTP是不保存状态的协议,如何保存用户状态?<br /></li>\n</ul>\n<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>\n<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>\n<p><strong>Cookie 被禁用怎么办?</strong></p>\n<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>\n<p><a href=\"https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67\"><img src=\"https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67#align=left&display=inline&height=309&originHeight=309&originWidth=859&status=done&style=none&width=859\" alt=\"\"></a></p>\n<ul>\n<li>Cookie的作用是什么?和Session有什么区别？<br /></li>\n</ul>\n<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>\n<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>\n<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>\n<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>\n<ul>\n<li>URI和URL的区别是什么?<br /><ul>\n<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>\n<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>\n</ul>\n</li>\n</ul>\n<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>\n<p><a name=\"d17a0f0b\"></a></p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E4%BA%94%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8\">https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#五具体应用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247483733&amp;idx=2&amp;sn=93b359af4397cd4afa791fdb5f51f0b5&amp;chksm=ebd74054dca0c942be5180cdf0f460ed7f534ca51230147fe0081df15adac76dac9e61d97761&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247483733&amp;idx=2&amp;sn=93b359af4397cd4afa791fdb5f51f0b5&amp;chksm=ebd74054dca0c942be5180cdf0f460ed7f534ca51230147fe0081df15adac76dac9e61d97761&amp;scene=21#wechat_redirect</a></li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%B8%83-%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\">https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/计算机网络.md#七-各种协议与http协议之间的关系</a></li>\n</ul>\n', '2020-03-22 10:16:35', '2020-03-23 06:37:05');
INSERT INTO `blog_article_content` VALUES ('1241677530356805633', '1241677530348417026', '## 一、mysql的基本存储结构\n首先Mysql的基本存储结构是**页**(记录都存在页里边)：\n\n![图片](https://uploader.shimo.im/f/HqOyFcUwMpYxCIQn.png!thumbnail)\n\n![图片](https://uploader.shimo.im/f/HtZ0aFBFgmkw70oI.png!thumbnail)\n\n* **各个数据页**可以组成一个**双向链表**\n* 而**每个数据页中的记录**又可以组成一个**单向**链表\n* null\n\n  * 每个数据页都会为存储在它里边儿的记录生成一个**页目录**，在通过**主键**查找某条记录的时候可以在页目录中使用**二分法快速定位**到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录\n  * 以**其他列**(非主键)作为搜索条件：只能从最小记录开始**依次遍历单链表中的每条记录**。\n\n所以说，如果我们写 select * from user where username=\'张三\'这样没有进行任何优化的sql语句，默认会这样做：\n\n* 定位到记录所在的页\n* 需要遍历双向链表，找到所在的页\n* 从所在的页内中查找相应的记录\n* 由于不是根据主键查询，只能遍历所在页的单链表了\n\n很明显，在数据量很大的情况下这样查找会**很慢**！\n\n## 二、索引的优缺点\n### 2.1 索引提高检索速度\n其实就是**将无序的数据变成有序(相对)**\n\n表的行格式示意图：\n\n![图片](https://uploader.shimo.im/f/2FUcELRqA888olvY.png!thumbnail)\n\n我们只在示意图里展示记录的这几个部分：\n\n* record_type：记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1我们还没用过，等会再说～\n* next_type：记录头信息的一项属性，表示下一条地址的偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。\n* 各个列的值：就是各个数据列的值，其中我们用橘黄色的格子代表c1列，深蓝色的格子代表c2列，红色格子代表c3列。\n* 其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。\n\n为了节省篇幅，我们之后的示意图中会把记录的其他信息这个部分省略掉。\n\n要找到id为8的记录简要步骤：\n\n![图片](https://uploader.shimo.im/f/LBloBj3ErpwM6TFZ.png!thumbnail)\n\n很明显的是：**没有用索引**我们是需要**遍历双向链表**来定位对应的页，现在通过**“目录”**就可以很快地定位到对应的页上了！\n\n其实底层结构就是**B+树**，B+树作为树的一种实现，能够让我们**很快地**查找出对应的记录。\n\n### 2.2 索引的优点\n* 大大减少了服务器需要扫描的数据行数。\n* 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。\n* 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。\n### 2.3 索引降低增删改的速度\nB+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合**矮矮胖胖(均衡)的结构**)【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。\n\n* B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构**。\n* **要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度\n## 三、索引使用的数据结构\n### 3.1 B+Tree索引\n3.1.1 数据结构\n\nB Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n![图片](https://uploader.shimo.im/f/g9nu70WQRtEJTsUy.png!thumbnail)\n\n**3.1.2 操作**\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。\n\n**3.1.3 与红黑树的比较**\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：\n\n（一）更少的查找次数\n\n平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。\n\n红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。\n\n（二）利用磁盘预读特性\n\n为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。\n\n操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n3.1.4 与B Tree比较\n\nB+ Tree磁盘内容都存在了叶子节点，相比B树，这样他一个节点可以存储更多的数据项，也就是说一个节点的出度更大，这样他的高度也就相比B树来说更小。\n\n### 3.2 哈希索引\n哈希索引就是采用一定的**哈希算法**，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可**立刻定位到相应的位置，速度非常快**。\n\n* 本质上就是**把键值换算成新的哈希值**，根据这个**哈希值来定位**。\n\n![图片](https://uploader.shimo.im/f/cE8DsVeQjwI1CQK1.png!thumbnail)\n\n* 看起来哈希索引很牛逼啊，但其实哈希索引有好几个局限(根据他本质的原理可得)：\n  * 哈希索引也没办法利用索引完成**排序**\n  * 不支持**最左匹配原则**\n  * 在有大量重复键值情况下，哈希索引的效率也是极低的---->**哈希碰撞**问题。\n  * **不支持范围查询**\n\nInnoDB支持哈希索引吗？\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n## 聚簇索引和非聚簇索引\nB+Tree结构都可以用在MyISAM和InnoDB上。mysql中，不同的存储引擎对索引的实现方式不同，大致说下MyISAM和InnoDB两种存储引擎。\n\nMyISAM的是非聚簇索引，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，\n\n这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。\n\nInnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用\"where id = 14\"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。\n\n![图片](https://uploader.shimo.im/f/9IrpfOqpVVMHIlgf.png!thumbnail)\n\n	聚集索引和非聚集索引原理图\n\n②聚簇索引\n\n聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。\n\n聚集索引这种主+辅索引的好处是，当发生数据行移动或者页分裂时，辅助索引树不需要更新，因为辅助索引树存储的是主索引的主键关键字，而不是数据具体的物理地址。\n\n③非聚簇索引\n\n非聚集索引，类似于图书的附录，那个专业术语出现在哪个章节，这些专业术语是有顺序的，但是出现的位置是没有顺序的。每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放。但是，一个表可以有不止一个非聚簇索引。\n\n\n## 四、聚集和非聚集索引\n简单概括：\n\n* 聚集索引就是以**主键**创建的索引\n* 非聚集索引就是以**非主键**创建的索引\n\n区别：\n\n* 聚集索引在叶子节点存储的是**表中的数据**\n* 非聚集索引在叶子节点存储的是**主键和索引列**\n* 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。(拿到主键再查找这个过程叫做**回表**)\n\n**非聚集索引也叫做二级索引**，不用纠结那么多名词，将其等价就行了~\n\n非聚集索引在建立的时候也**未必是单列**的，可以多个列来创建索引。\n\n* 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则-->后面有说)\n* **创建多个单列(非聚集)索引的时候，会生成多个索引树**(所以过多创建索引会占用磁盘空间)\n\n![图片](https://uploader.shimo.im/f/JkLNae9YZa0TtXJZ.png!thumbnail)\n\n## 五、覆盖索引\n在创建多列索引中也涉及到了一种特殊的索引-->**覆盖索引**\n\n* 我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值\n* 最终还是要“回表”，也就是要通过主键**再**查找一次。这样就会比较慢\n* 覆盖索引就是把要**查询出的列和索引是对应的**，不做回表操作！（注意是查询出来的列不是查询条件的列）\n\n比如说：\n\n* 现在我创建了索引 (username,age)，在查询数据的时候： select username,age from user where username=\'Java3y\' and age=20。\n* 很明显地知道，我们上边的查询是走索引的，并且，**要查询出的列在叶子节点都存在**！所以，就不用回表了~\n* 所以，能使用覆盖索引就尽量使用吧~\n## 六、索引最左匹配原则\n* 索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即**联合索引**。\n* 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询 (>、<、between、like左匹配)等就**不能进一步匹配**了，后续退化为线性查找。\n* 因此，**列的排列顺序决定了可命中索引的列数**。\n\n例子：\n\n* 如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)\n\n为什么能命中c？\n\n举个简单例子： select * from user where age>30; 如果在age列创建索引，那你说会走索引吗？\n\n=、in自动优化顺序\n\n**不需要考虑=、in等的顺序**，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。\n\n例子：\n\n* 如有索引 (a,b,c,d)，查询条件 c>3 and b=2 and a=1 and d<4与 a=1 and c>3 and b=2 and d<4等顺序都是可以的，MySQL会自动优化为 a=1 and b=2 and c>3 and d<4，依次命中a、b、c。\n## 七、唯一索引\n普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。\n\n如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。\n\n## 七、索引的使用条件\n* 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n* 对于中到大型的表，索引就非常有效；\n* 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n## 八、索引优化\n### 8.1 独立的列\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n\n例如下面的查询不能使用 actor_id 列的索引：\n\nSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n\n### 8.2 多列索引\n在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\n\nSELECT film_id, actor_ id FROM sakila.film_actor\n\nWHERE actor_id = 1 AND film_id = 1;\n\n### 8.3 索引列的顺序\n让选择性最强的索引列放在前面。\n\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\nSELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,\n\nCOUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,\n\nCOUNT(*)\n\nFROM payment;\n\n   staff_id_selectivity: 0.0001\n\ncustomer_id_selectivity: 0.0373\n\n               COUNT(*): 16049\n\n### 8.4 前缀索引\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n\n前缀长度的选取需要根据索引选择性来确定。\n\n### 8.5 覆盖索引\n索引包含所有需要查询的字段的值。\n\n具有以下优点：\n\n* 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n* 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n* 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n## 面试\n### InnoDB引擎主键为什么设成自增\n上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。\n\n如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：\n\n![图片](https://uploader.shimo.im/f/DBsySeJVKQQsnYmc.png!thumbnail)\n\n这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。\n\n如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：\n\n![图片](https://uploader.shimo.im/f/iVYPSijHcX0S0mly.png!thumbnail)\n\n此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。\n\n因此，只要可以，请尽量在InnoDB上采用自增字段做主键。\n\n**顺序主键什么时候回造成更会坏的结果？**\n\n对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键上界会成为”热点”，因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制：如果遇到这个问题，则可能需要考虑重新设计表或者应用，或者更改innodb_autoinc_lock_mode配置。\n\n自增长在数据库中是非常常见的一种属性，也是很多DBA或开发人员首选的主键方式。在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化，执行如下的语句来得到计数器的值：\n\n| 1 | select max(auto_inc_col) from t for update; | \n|----|----|\n插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称为AUTO-INC Locking。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放。\n\n虽然AUTO-INC Locking从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成，虽然不用等待事务的完成。其次，对于INSERT….SELECT的大数据的插入会影响插入的性能，因为另一个事务中的插入会被阻塞。\n\n从MySQL 5.1.22版本开始，InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引擎提供了一个参数innodb_autoinc_lock_mode来控制自增长的模式，该参数的默认值为1。在继续讨论新的自增长实现方式之前，需要对自增长的插入进行分类。如下说明：\n\n* **insert-like**：指所有的插入语句，如INSERT、REPLACE、INSERT…SELECT，REPLACE…SELECT、LOAD DATA等。\n* **simple inserts**：指能在插入前就确定插入行数的语句，这些语句包括INSERT、REPLACE等。需要注意的是：simple inserts不包含INSERT…ON DUPLICATE KEY UPDATE这类SQL语句。\n* **bulk inserts**：指在插入前不能确定得到插入行数的语句，如INSERT…SELECT，REPLACE…SELECT，LOAD DATA。\n* **mixed-mode inserts**：指插入中有一部分的值是自增长的，有一部分是确定的。入INSERT INTO t1(c1,c2) VALUES(1,’a’),(2,’a’),(3,’a’)；也可以是指INSERT…ON DUPLICATE KEY UPDATE这类SQL语句。\n\n接下来分析参数innodb_autoinc_lock_mode以及各个设置下对自增长的影响，其总共有三个有效值可供设定，即0、1、2，具体说明如下：\n\n* **0**：这是MySQL 5.1.22版本之前自增长的实现方式，即通过表锁的AUTO-INC Locking方式，因为有了新的自增长实现方式，0这个选项不应该是新版用户的首选了。\n* **1**：这是该参数的默认值，对于”simple inserts”，该值会用互斥量（mutex）去对内存中的计数器进行累加的操作。对于”bulk inserts”，还是使用传统表锁的AUTO-INC Locking方式。在这种配置下，如果不考虑回滚操作，对于自增值列的增长还是连续的。并且在这种方式下，statement-based方式的replication还是能很好地工作。需要注意的是，如果已经使用AUTO-INC Locing方式去产生自增长的值，而这时需要再进行”simple inserts”的操作时，还是需要等待AUTO-INC Locking的释放。\n* **2**：在这个模式下，对于所有”INSERT-LIKE”自增长值的产生都是通过互斥量，而不是AUTO-INC Locking的方式。显然，这是性能最高的方式。然而，这会带来一定的问题，因为并发插入的存在，在每次插入时，自增长的值可能不是连续的。此外，最重要的是，基于Statement-Base Replication会出现问题。因此，使用这个模式，任何时候都应该使用row-base replication。这样才能保证最大的并发性能及replication主从数据的一致。\n\n这里需要特别注意，InnoDB跟MyISAM不同，MyISAM存储引擎是表锁设计，自增长不用考虑并发插入的问题。因此在master上用InnoDB存储引擎，在slave上用MyISAM存储引擎的replication架构下，用户可以考虑这种情况。\n\n另外，InnoDB存储引擎，自增持列必须是索引，同时必须是索引的第一个列，如果不是第一个列，会抛出异常，而MyiSAM不会有这个问题。\n\n| 12 | mysql>createtabletest(idintprimarykeynotnull,countintauto_incrementnotnull);ERROR1075(42000):Incorrecttabledefinition;therecanbeonlyoneautocolumnanditmustbedefinedasakey | \n|----|----|\n\n\n## 参考\n* [https://zhuanlan.zhihu.com/p/23624390](https://zhuanlan.zhihu.com/p/23624390)\n* [https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=1&sn=410dea1863ba823bec802769e1e6fe8a&chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&token=1676899695&lang=zh_CN###rd](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=1&sn=410dea1863ba823bec802769e1e6fe8a&chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&token=1676899695&lang=zh_CN###rd)\n* null\n\n', '<h2 id=\"一、mysql的基本存储结构\">一、mysql的基本存储结构</h2>\n<p>首先Mysql的基本存储结构是<strong>页</strong>(记录都存在页里边)：</p>\n<p><img src=\"https://uploader.shimo.im/f/HqOyFcUwMpYxCIQn.png!thumbnail\" alt=\"图片\"></p>\n<p><img src=\"https://uploader.shimo.im/f/HtZ0aFBFgmkw70oI.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li><p><strong>各个数据页</strong>可以组成一个<strong>双向链表</strong></p>\n</li>\n<li><p>而<strong>每个数据页中的记录</strong>又可以组成一个<strong>单向</strong>链表</p>\n</li>\n<li><p>null</p>\n<ul>\n<li>每个数据页都会为存储在它里边儿的记录生成一个<strong>页目录</strong>，在通过<strong>主键</strong>查找某条记录的时候可以在页目录中使用<strong>二分法快速定位</strong>到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>\n<li>以<strong>其他列</strong>(非主键)作为搜索条件：只能从最小记录开始<strong>依次遍历单链表中的每条记录</strong>。</li>\n</ul>\n</li>\n</ul>\n<p>所以说，如果我们写 select * from user where username=&#39;张三&#39;这样没有进行任何优化的sql语句，默认会这样做：</p>\n<ul>\n<li>定位到记录所在的页</li>\n<li>需要遍历双向链表，找到所在的页</li>\n<li>从所在的页内中查找相应的记录</li>\n<li>由于不是根据主键查询，只能遍历所在页的单链表了</li>\n</ul>\n<p>很明显，在数据量很大的情况下这样查找会<strong>很慢</strong>！</p>\n<h2 id=\"二、索引的优缺点\">二、索引的优缺点</h2>\n<h3 id=\"21-索引提高检索速度\">2.1 索引提高检索速度</h3>\n<p>其实就是<strong>将无序的数据变成有序(相对)</strong></p>\n<p>表的行格式示意图：</p>\n<p><img src=\"https://uploader.shimo.im/f/2FUcELRqA888olvY.png!thumbnail\" alt=\"图片\"></p>\n<p>我们只在示意图里展示记录的这几个部分：</p>\n<ul>\n<li>record_type：记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1我们还没用过，等会再说～</li>\n<li>next_type：记录头信息的一项属性，表示下一条地址的偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</li>\n<li>各个列的值：就是各个数据列的值，其中我们用橘黄色的格子代表c1列，深蓝色的格子代表c2列，红色格子代表c3列。</li>\n<li>其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>\n</ul>\n<p>为了节省篇幅，我们之后的示意图中会把记录的其他信息这个部分省略掉。</p>\n<p>要找到id为8的记录简要步骤：</p>\n<p><img src=\"https://uploader.shimo.im/f/LBloBj3ErpwM6TFZ.png!thumbnail\" alt=\"图片\"></p>\n<p>很明显的是：<strong>没有用索引</strong>我们是需要<strong>遍历双向链表</strong>来定位对应的页，现在通过<strong>“目录”</strong>就可以很快地定位到对应的页上了！</p>\n<p>其实底层结构就是<strong>B+树</strong>，B+树作为树的一种实现，能够让我们<strong>很快地</strong>查找出对应的记录。</p>\n<h3 id=\"22-索引的优点\">2.2 索引的优点</h3>\n<ul>\n<li><p>大大减少了服务器需要扫描的数据行数。</p>\n</li>\n<li><p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>\n</li>\n<li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p>\n<h3 id=\"23-索引降低增删改的速度\">2.3 索引降低增删改的速度</h3>\n<p>B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合<strong>矮矮胖胖(均衡)的结构</strong>)【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。</p>\n</li>\n<li><p>B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会<strong>破坏它的原有结构</strong>。</p>\n</li>\n<li><p><strong>要维持平衡树，就必须做额外的工作</strong>。正因为这些额外的工作<strong>开销</strong>，导致索引会降低增删改的速度</p>\n<h2 id=\"三、索引使用的数据结构\">三、索引使用的数据结构</h2>\n<h3 id=\"31-btree索引\">3.1 B+Tree索引</h3>\n</li>\n</ul>\n<p>3.1.1 数据结构</p>\n<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<p><img src=\"https://uploader.shimo.im/f/g9nu70WQRtEJTsUy.png!thumbnail\" alt=\"图片\"></p>\n<p><strong>3.1.2 操作</strong></p>\n<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>\n<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>\n<p><strong>3.1.3 与红黑树的比较</strong></p>\n<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>\n<p>（一）更少的查找次数</p>\n<p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p>\n<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>\n<p>（二）利用磁盘预读特性</p>\n<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>\n<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<p>3.1.4 与B Tree比较</p>\n<p>B+ Tree磁盘内容都存在了叶子节点，相比B树，这样他一个节点可以存储更多的数据项，也就是说一个节点的出度更大，这样他的高度也就相比B树来说更小。</p>\n<h3 id=\"32-哈希索引\">3.2 哈希索引</h3>\n<p>哈希索引就是采用一定的<strong>哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可<strong>立刻定位到相应的位置，速度非常快</strong>。</p>\n<ul>\n<li>本质上就是<strong>把键值换算成新的哈希值</strong>，根据这个<strong>哈希值来定位</strong>。</li>\n</ul>\n<p><img src=\"https://uploader.shimo.im/f/cE8DsVeQjwI1CQK1.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li>看起来哈希索引很牛逼啊，但其实哈希索引有好几个局限(根据他本质的原理可得)：<ul>\n<li>哈希索引也没办法利用索引完成<strong>排序</strong></li>\n<li>不支持<strong>最左匹配原则</strong></li>\n<li>在有大量重复键值情况下，哈希索引的效率也是极低的----&gt;<strong>哈希碰撞</strong>问题。</li>\n<li><strong>不支持范围查询</strong></li>\n</ul>\n</li>\n</ul>\n<p>InnoDB支持哈希索引吗？</p>\n<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n<h2 id=\"聚簇索引和非聚簇索引\">聚簇索引和非聚簇索引</h2>\n<p>B+Tree结构都可以用在MyISAM和InnoDB上。mysql中，不同的存储引擎对索引的实现方式不同，大致说下MyISAM和InnoDB两种存储引擎。</p>\n<p>MyISAM的是非聚簇索引，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，</p>\n<p>这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。</p>\n<p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用&quot;where id = 14&quot;这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p>\n<p><img src=\"https://uploader.shimo.im/f/9IrpfOqpVVMHIlgf.png!thumbnail\" alt=\"图片\"></p>\n<pre><code>聚集索引和非聚集索引原理图</code></pre><p>②聚簇索引</p>\n<p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。</p>\n<p>聚集索引这种主+辅索引的好处是，当发生数据行移动或者页分裂时，辅助索引树不需要更新，因为辅助索引树存储的是主索引的主键关键字，而不是数据具体的物理地址。</p>\n<p>③非聚簇索引</p>\n<p>非聚集索引，类似于图书的附录，那个专业术语出现在哪个章节，这些专业术语是有顺序的，但是出现的位置是没有顺序的。每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放。但是，一个表可以有不止一个非聚簇索引。</p>\n<h2 id=\"四、聚集和非聚集索引\">四、聚集和非聚集索引</h2>\n<p>简单概括：</p>\n<ul>\n<li>聚集索引就是以<strong>主键</strong>创建的索引</li>\n<li>非聚集索引就是以<strong>非主键</strong>创建的索引</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>聚集索引在叶子节点存储的是<strong>表中的数据</strong></li>\n<li>非聚集索引在叶子节点存储的是<strong>主键和索引列</strong></li>\n<li>使用非聚集索引查询出数据时，<strong>拿到叶子上的主键再去查到想要查找的数据</strong>。(拿到主键再查找这个过程叫做<strong>回表</strong>)</li>\n</ul>\n<p><strong>非聚集索引也叫做二级索引</strong>，不用纠结那么多名词，将其等价就行了~</p>\n<p>非聚集索引在建立的时候也<strong>未必是单列</strong>的，可以多个列来创建索引。</p>\n<ul>\n<li>此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则--&gt;后面有说)</li>\n<li><strong>创建多个单列(非聚集)索引的时候，会生成多个索引树</strong>(所以过多创建索引会占用磁盘空间)</li>\n</ul>\n<p><img src=\"https://uploader.shimo.im/f/JkLNae9YZa0TtXJZ.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"五、覆盖索引\">五、覆盖索引</h2>\n<p>在创建多列索引中也涉及到了一种特殊的索引--&gt;<strong>覆盖索引</strong></p>\n<ul>\n<li>我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值</li>\n<li>最终还是要“回表”，也就是要通过主键<strong>再</strong>查找一次。这样就会比较慢</li>\n<li>覆盖索引就是把要<strong>查询出的列和索引是对应的</strong>，不做回表操作！（注意是查询出来的列不是查询条件的列）</li>\n</ul>\n<p>比如说：</p>\n<ul>\n<li>现在我创建了索引 (username,age)，在查询数据的时候： select username,age from user where username=&#39;Java3y&#39; and age=20。</li>\n<li>很明显地知道，我们上边的查询是走索引的，并且，<strong>要查询出的列在叶子节点都存在</strong>！所以，就不用回表了~</li>\n<li>所以，能使用覆盖索引就尽量使用吧~<h2 id=\"六、索引最左匹配原则\">六、索引最左匹配原则</h2>\n</li>\n<li>索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即<strong>联合索引</strong>。</li>\n<li>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询 (&gt;、&lt;、between、like左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li>\n<li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li>\n</ul>\n<p>例子：</p>\n<ul>\n<li>如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c&gt;3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)</li>\n</ul>\n<p>为什么能命中c？</p>\n<p>举个简单例子： select * from user where age&gt;30; 如果在age列创建索引，那你说会走索引吗？</p>\n<p>=、in自动优化顺序</p>\n<p><strong>不需要考虑=、in等的顺序</strong>，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>\n<p>例子：</p>\n<ul>\n<li>如有索引 (a,b,c,d)，查询条件 c&gt;3 and b=2 and a=1 and d&lt;4与 a=1 and c&gt;3 and b=2 and d&lt;4等顺序都是可以的，MySQL会自动优化为 a=1 and b=2 and c&gt;3 and d&lt;4，依次命中a、b、c。<h2 id=\"七、唯一索引\">七、唯一索引</h2>\n普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。</li>\n</ul>\n<p>如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p>\n<h2 id=\"七、索引的使用条件\">七、索引的使用条件</h2>\n<ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。<h2 id=\"八、索引优化\">八、索引优化</h2>\n<h3 id=\"81-独立的列\">8.1 独立的列</h3>\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</li>\n</ul>\n<p>例如下面的查询不能使用 actor_id 列的索引：</p>\n<p>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</p>\n<h3 id=\"82-多列索引\">8.2 多列索引</h3>\n<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<p>SELECT film_id, actor_ id FROM sakila.film_actor</p>\n<p>WHERE actor_id = 1 AND film_id = 1;</p>\n<h3 id=\"83-索引列的顺序\">8.3 索引列的顺序</h3>\n<p>让选择性最强的索引列放在前面。</p>\n<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>\n<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<p>SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</p>\n<p>COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</p>\n<p>COUNT(*)</p>\n<p>FROM payment;</p>\n<p>   staff_id_selectivity: 0.0001</p>\n<p>customer_id_selectivity: 0.0373</p>\n<pre><code>           COUNT(*): 16049</code></pre><h3 id=\"84-前缀索引\">8.4 前缀索引</h3>\n<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>\n<p>前缀长度的选取需要根据索引选择性来确定。</p>\n<h3 id=\"85-覆盖索引\">8.5 覆盖索引</h3>\n<p>索引包含所有需要查询的字段的值。</p>\n<p>具有以下优点：</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>\n<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>\n<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。<h2 id=\"面试\">面试</h2>\n<h3 id=\"innodb引擎主键为什么设成自增\">InnoDB引擎主键为什么设成自增</h3>\n上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</li>\n</ul>\n<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>\n<p><img src=\"https://uploader.shimo.im/f/DBsySeJVKQQsnYmc.png!thumbnail\" alt=\"图片\"></p>\n<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>\n<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>\n<p><img src=\"https://uploader.shimo.im/f/iVYPSijHcX0S0mly.png!thumbnail\" alt=\"图片\"></p>\n<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>\n<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>\n<p><strong>顺序主键什么时候回造成更会坏的结果？</strong></p>\n<p>对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键上界会成为”热点”，因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制：如果遇到这个问题，则可能需要考虑重新设计表或者应用，或者更改innodb_autoinc_lock_mode配置。</p>\n<p>自增长在数据库中是非常常见的一种属性，也是很多DBA或开发人员首选的主键方式。在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化，执行如下的语句来得到计数器的值：</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>select max(auto_inc_col) from t for update;</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称为AUTO-INC Locking。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放。</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>虽然AUTO-INC Locking从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成，虽然不用等待事务的完成。其次，对于INSERT….SELECT的大数据的插入会影响插入的性能，因为另一个事务中的插入会被阻塞。</p>\n<p>从MySQL 5.1.22版本开始，InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引擎提供了一个参数innodb_autoinc_lock_mode来控制自增长的模式，该参数的默认值为1。在继续讨论新的自增长实现方式之前，需要对自增长的插入进行分类。如下说明：</p>\n<ul>\n<li><strong>insert-like</strong>：指所有的插入语句，如INSERT、REPLACE、INSERT…SELECT，REPLACE…SELECT、LOAD DATA等。</li>\n<li><strong>simple inserts</strong>：指能在插入前就确定插入行数的语句，这些语句包括INSERT、REPLACE等。需要注意的是：simple inserts不包含INSERT…ON DUPLICATE KEY UPDATE这类SQL语句。</li>\n<li><strong>bulk inserts</strong>：指在插入前不能确定得到插入行数的语句，如INSERT…SELECT，REPLACE…SELECT，LOAD DATA。</li>\n<li><strong>mixed-mode inserts</strong>：指插入中有一部分的值是自增长的，有一部分是确定的。入INSERT INTO t1(c1,c2) VALUES(1,’a’),(2,’a’),(3,’a’)；也可以是指INSERT…ON DUPLICATE KEY UPDATE这类SQL语句。</li>\n</ul>\n<p>接下来分析参数innodb_autoinc_lock_mode以及各个设置下对自增长的影响，其总共有三个有效值可供设定，即0、1、2，具体说明如下：</p>\n<ul>\n<li><strong>0</strong>：这是MySQL 5.1.22版本之前自增长的实现方式，即通过表锁的AUTO-INC Locking方式，因为有了新的自增长实现方式，0这个选项不应该是新版用户的首选了。</li>\n<li><strong>1</strong>：这是该参数的默认值，对于”simple inserts”，该值会用互斥量（mutex）去对内存中的计数器进行累加的操作。对于”bulk inserts”，还是使用传统表锁的AUTO-INC Locking方式。在这种配置下，如果不考虑回滚操作，对于自增值列的增长还是连续的。并且在这种方式下，statement-based方式的replication还是能很好地工作。需要注意的是，如果已经使用AUTO-INC Locing方式去产生自增长的值，而这时需要再进行”simple inserts”的操作时，还是需要等待AUTO-INC Locking的释放。</li>\n<li><strong>2</strong>：在这个模式下，对于所有”INSERT-LIKE”自增长值的产生都是通过互斥量，而不是AUTO-INC Locking的方式。显然，这是性能最高的方式。然而，这会带来一定的问题，因为并发插入的存在，在每次插入时，自增长的值可能不是连续的。此外，最重要的是，基于Statement-Base Replication会出现问题。因此，使用这个模式，任何时候都应该使用row-base replication。这样才能保证最大的并发性能及replication主从数据的一致。</li>\n</ul>\n<p>这里需要特别注意，InnoDB跟MyISAM不同，MyISAM存储引擎是表锁设计，自增长不用考虑并发插入的问题。因此在master上用InnoDB存储引擎，在slave上用MyISAM存储引擎的replication架构下，用户可以考虑这种情况。</p>\n<p>另外，InnoDB存储引擎，自增持列必须是索引，同时必须是索引的第一个列，如果不是第一个列，会抛出异常，而MyiSAM不会有这个问题。</p>\n<table>\n<thead>\n<tr>\n<th>12</th>\n<th>mysql&gt;createtabletest(idintprimarykeynotnull,countintauto_incrementnotnull);ERROR1075(42000):Incorrecttabledefinition;therecanbeonlyoneautocolumnanditmustbedefinedasakey</th>\n</tr>\n</thead>\n</table>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23624390\">https://zhuanlan.zhihu.com/p/23624390</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484721&amp;idx=1&amp;sn=410dea1863ba823bec802769e1e6fe8a&amp;chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&amp;token=1676899695&amp;lang=zh_CN###rd\">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484721&amp;idx=1&amp;sn=410dea1863ba823bec802769e1e6fe8a&amp;chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&amp;token=1676899695&amp;lang=zh_CN###rd</a></li>\n<li>null</li>\n</ul>\n', '2020-03-22 10:46:07', '2020-03-23 04:22:06');

-- ----------------------------
-- Table structure for blog_article_info
-- ----------------------------
DROP TABLE IF EXISTS `blog_article_info`;
CREATE TABLE `blog_article_info` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，文章ID',
  `title` varchar(50) NOT NULL COMMENT '文章标题',
  `summary` varchar(300) DEFAULT '' COMMENT '文章摘要',
  `author` varchar(50) DEFAULT '' COMMENT '作者',
  `category_id` varchar(40) DEFAULT '' COMMENT '所属分类',
  `is_publish` tinyint(1) NOT NULL DEFAULT '0' COMMENT '发布状态',
  `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '文章是否置顶',
  `is_recommend` tinyint(1) NOT NULL DEFAULT '0' COMMENT '文章是否被推荐',
  `read_num` int(11) NOT NULL DEFAULT '0' COMMENT '阅读数量',
  `comment_num` int(11) NOT NULL DEFAULT '0' COMMENT '评论数量',
  `like_num` int(11) NOT NULL DEFAULT '0' COMMENT '点赞数量',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1241970760696840195 DEFAULT CHARSET=utf8 COMMENT='文章信息表';

-- ----------------------------
-- Records of blog_article_info
-- ----------------------------
INSERT INTO `blog_article_info` VALUES ('1', '个人介绍', '个人的介绍', 'anyue', '', '0', '0', '0', '0', '0', '0', '2020-03-18 13:49:02', '2020-03-18 13:49:02');
INSERT INTO `blog_article_info` VALUES ('1241670095483281410', 'http', 'http协议知识', 'lxy', '1', '1', '0', '1', '0', '0', '0', '2020-03-22 10:16:35', '2020-03-23 06:42:55');
INSERT INTO `blog_article_info` VALUES ('1241677530348417026', '索引', '', 'lxy', '1', '1', '0', '0', '0', '0', '0', '2020-03-22 10:46:07', '2020-03-23 04:22:06');

-- ----------------------------
-- Table structure for blog_article_message
-- ----------------------------
DROP TABLE IF EXISTS `blog_article_message`;
CREATE TABLE `blog_article_message` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `article_id` bigint(40) NOT NULL COMMENT '对应文章id',
  `message_id` bigint(40) NOT NULL COMMENT '对应留言id',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1有效，为0无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章评论表';

-- ----------------------------
-- Records of blog_article_message
-- ----------------------------

-- ----------------------------
-- Table structure for blog_article_picture
-- ----------------------------
DROP TABLE IF EXISTS `blog_article_picture`;
CREATE TABLE `blog_article_picture` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `article_id` bigint(40) NOT NULL COMMENT '文章id',
  `picture_url` varchar(100) NOT NULL DEFAULT '' COMMENT '图片URL',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章题图表';

-- ----------------------------
-- Records of blog_article_picture
-- ----------------------------

-- ----------------------------
-- Table structure for blog_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `blog_article_tag`;
CREATE TABLE `blog_article_tag` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `tag_id` bigint(40) NOT NULL COMMENT '标签id',
  `article_id` bigint(40) NOT NULL COMMENT '文章id',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1有效，为0无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1241977246047047683 DEFAULT CHARSET=utf8 COMMENT='文章标签表';

-- ----------------------------
-- Records of blog_article_tag
-- ----------------------------
INSERT INTO `blog_article_tag` VALUES ('1241977246047047682', '2', '1241670095483281410', '2020-03-23 06:37:05', '2020-03-23 06:37:05', '1');

-- ----------------------------
-- Table structure for blog_category_info
-- ----------------------------
DROP TABLE IF EXISTS `blog_category_info`;
CREATE TABLE `blog_category_info` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `category_name` varchar(20) NOT NULL DEFAULT '' COMMENT '分类名称',
  `category_number` tinyint(10) NOT NULL DEFAULT '0' COMMENT '该分类下的文章数量',
  `category_rank` int(11) NOT NULL DEFAULT '1' COMMENT '分类等级',
  `parent_id` bigint(40) NOT NULL DEFAULT '-1' COMMENT '父目录，默认-1表示当前等级是最高，没有父目录',
  `type` int(11) NOT NULL DEFAULT '0' COMMENT '标识文章类型，普通0，读后感1',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1有效，为0无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1241971538824032259 DEFAULT CHARSET=utf8 COMMENT='分类信息表';

-- ----------------------------
-- Records of blog_category_info
-- ----------------------------
INSERT INTO `blog_category_info` VALUES ('1', 'java', '0', '1', '-1', '0', '2020-03-14 18:24:00', '2020-03-14 18:24:00', '1');
INSERT INTO `blog_category_info` VALUES ('2', 'java多线程', '0', '2', '1', '0', '2020-03-14 18:24:22', '2020-03-14 18:24:22', '1');
INSERT INTO `blog_category_info` VALUES ('5', 'java基础', '0', '2', '1', '0', '2020-03-16 21:17:06', '2020-03-16 21:17:06', '1');
INSERT INTO `blog_category_info` VALUES ('1241968754330492930', '数据库', '0', '1', '-1', '0', '2020-03-23 06:03:20', '2020-03-23 06:03:20', '1');
INSERT INTO `blog_category_info` VALUES ('1241968859066458114', 'mysql', '0', '2', '1241968754330492930', '0', '2020-03-23 06:03:45', '2020-03-23 06:03:45', '1');
INSERT INTO `blog_category_info` VALUES ('1241971538824032258', '网络', '0', '1', '-1', '0', '2020-03-23 06:14:24', '2020-03-23 06:25:15', '1');

-- ----------------------------
-- Table structure for blog_link
-- ----------------------------
DROP TABLE IF EXISTS `blog_link`;
CREATE TABLE `blog_link` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `title` varchar(50) DEFAULT NULL COMMENT '友链名称',
  `url` varchar(500) DEFAULT NULL COMMENT '友链地址',
  `avator` varchar(255) DEFAULT NULL COMMENT '头像',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1241978047461101571 DEFAULT CHARSET=utf8 COMMENT='友链表';

-- ----------------------------
-- Records of blog_link
-- ----------------------------
INSERT INTO `blog_link` VALUES ('1', '111', 'https://go.sspai.com/matrix', null, '2020-03-17 14:19:00', '2020-03-17 14:19:00');
INSERT INTO `blog_link` VALUES ('2', '222', 'https://go.sspai.com/matrix', null, '2020-03-17 14:19:15', '2020-03-17 14:19:15');
INSERT INTO `blog_link` VALUES ('3', 'GitHub', 'https://github.com/', null, '2020-03-17 14:19:24', '2020-03-23 06:41:24');
INSERT INTO `blog_link` VALUES ('1241978047461101570', '掘金', 'https://juejin.im/timeline', null, '2020-03-23 06:40:16', '2020-03-23 06:40:16');

-- ----------------------------
-- Table structure for blog_message
-- ----------------------------
DROP TABLE IF EXISTS `blog_message`;
CREATE TABLE `blog_message` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `message_content` varchar(200) NOT NULL DEFAULT '' COMMENT '留言内容',
  `email` varchar(20) NOT NULL DEFAULT '' COMMENT '邮箱，用于回复消息',
  `name` varchar(20) NOT NULL DEFAULT '' COMMENT '用户自己定义的名称',
  `ip` varchar(20) NOT NULL DEFAULT '' COMMENT '留言ip',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1有效，为0无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='留言/评论表';

-- ----------------------------
-- Records of blog_message
-- ----------------------------

-- ----------------------------
-- Table structure for blog_recommend
-- ----------------------------
DROP TABLE IF EXISTS `blog_recommend`;
CREATE TABLE `blog_recommend` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `link_id` bigint(40) DEFAULT NULL COMMENT '推荐的文章id',
  `type` int(11) DEFAULT NULL COMMENT '推荐类型',
  `order_num` int(11) DEFAULT NULL COMMENT '顺序',
  `title` varchar(100) DEFAULT NULL COMMENT '标题',
  `top` tinyint(1) DEFAULT NULL COMMENT '置顶',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1241978715370459138 DEFAULT CHARSET=utf8 COMMENT='推荐表';

-- ----------------------------
-- Records of blog_recommend
-- ----------------------------
INSERT INTO `blog_recommend` VALUES ('1241978715370459137', '1241677530348417026', '0', '2', '索引', '1', '2020-03-23 06:42:55', '2020-03-23 06:44:02');

-- ----------------------------
-- Table structure for blog_tag_info
-- ----------------------------
DROP TABLE IF EXISTS `blog_tag_info`;
CREATE TABLE `blog_tag_info` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `tag_name` varchar(20) NOT NULL DEFAULT '' COMMENT '标签名称',
  `type` int(11) NOT NULL DEFAULT '0' COMMENT '标签类型，文章0，读后感1',
  `tag_number` tinyint(10) NOT NULL DEFAULT '0' COMMENT '该标签下的文章数量',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1有效，为0无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1241975772860674051 DEFAULT CHARSET=utf8 COMMENT='标签信息表';

-- ----------------------------
-- Records of blog_tag_info
-- ----------------------------
INSERT INTO `blog_tag_info` VALUES ('2', '多线程', '0', '1', '2020-03-14 22:26:58', '2020-03-23 06:37:05', '1');
INSERT INTO `blog_tag_info` VALUES ('5', '计网', '0', '0', '2020-03-16 21:50:51', '2020-03-23 06:30:54', '1');
INSERT INTO `blog_tag_info` VALUES ('1241975772860674050', 'mysql', '0', '0', '2020-03-23 06:31:14', '2020-03-23 06:34:59', '1');

-- ----------------------------
-- Table structure for sys_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_log`;
CREATE TABLE `sys_log` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `log_ip` varchar(200) NOT NULL DEFAULT '' COMMENT '操作地址的IP',
  `remark` varchar(255) NOT NULL DEFAULT '' COMMENT '操作内容',
  `operate_url` varchar(50) NOT NULL DEFAULT '' COMMENT '操作的访问地址',
  `operate_by` varchar(20) NOT NULL DEFAULT '' COMMENT '操作的浏览器',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='日志表';

-- ----------------------------
-- Records of sys_log
-- ----------------------------

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu` (
  `menu_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `parent_id` bigint(20) DEFAULT NULL,
  `name` tinytext,
  `url` varchar(200) DEFAULT NULL,
  `perms` varchar(500) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `icon` tinytext,
  `order_num` int(11) DEFAULT NULL,
  PRIMARY KEY (`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=86 DEFAULT CHARSET=utf8 COMMENT='菜单管理';

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES ('1', '0', '系统管理', null, null, '0', 'config', '3');
INSERT INTO `sys_menu` VALUES ('2', '1', '管理员列表', 'sys/user', null, '1', 'admin', '1');
INSERT INTO `sys_menu` VALUES ('3', '1', '角色管理', 'sys/role', null, '1', 'role', '2');
INSERT INTO `sys_menu` VALUES ('4', '1', '菜单管理', 'sys/menu', null, '1', 'menu', '3');
INSERT INTO `sys_menu` VALUES ('5', '1', 'SQL监控', 'http://localhost:8080/druid/sql.html', null, '1', 'config', '5');
INSERT INTO `sys_menu` VALUES ('15', '2', '查看', null, 'sys:user:list,sys:user:info', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('16', '2', '新增', null, 'sys:user:save,sys:role:select', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('17', '2', '修改', null, 'sys:user:update,sys:role:select', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('18', '2', '删除', null, 'sys:user:delete', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('19', '3', '查看', null, 'sys:role:list,sys:role:info', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('20', '3', '新增', null, 'sys:role:save,sys:menu:list', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('21', '3', '修改', null, 'sys:role:update,sys:menu:list', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('22', '3', '删除', null, 'sys:role:delete', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('23', '4', '查看', null, 'sys:menu:list,sys:menu:info', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('24', '4', '新增', null, 'sys:menu:save,sys:menu:select', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('25', '4', '修改', null, 'sys:menu:update,sys:menu:select', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('26', '4', '删除', null, 'sys:menu:delete', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('30', '0', '博文管理', null, null, '0', 'article', '0');
INSERT INTO `sys_menu` VALUES ('31', '30', '新增博文', 'article/article-add-or-update', 'article:save,article:update', '1', 'add', '0');
INSERT INTO `sys_menu` VALUES ('32', '30', '博文列表', 'article/article', null, '1', 'list', '0');
INSERT INTO `sys_menu` VALUES ('33', '32', '删除', null, 'article:delete', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('34', '32', '查看', null, 'article:list', '2', null, '0');
INSERT INTO `sys_menu` VALUES ('38', '43', '分类管理', 'operation/category', null, '1', 'category', '6');
INSERT INTO `sys_menu` VALUES ('39', '38', '查看', null, 'operation:category:list,operation:category:info', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('40', '38', '新增', null, 'operation:category:save', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('41', '38', '修改', null, 'operation:category:update', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('42', '38', '删除', null, 'operation:category:delete', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('43', '0', '运营管理', null, null, '0', 'operation', '2');
INSERT INTO `sys_menu` VALUES ('45', '1', '系统参数', 'sys/param', null, '1', 'param', '4');
INSERT INTO `sys_menu` VALUES ('46', '45', '查看', null, 'sys:param:list,sys:param:info', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('47', '45', '新增', null, 'sys:param:save', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('48', '45', '修改', null, 'sys:param:update', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('49', '45', '删除', null, 'sys:param:delete', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('50', '43', '标签管理', 'operation/tag', null, '1', 'tag', '6');
INSERT INTO `sys_menu` VALUES ('51', '50', '查看', null, 'operation:tag:list,operation:tag:info', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('52', '50', '新增', null, 'operation:tag:save', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('53', '50', '修改', null, 'operation:tag:update', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('54', '50', '删除', null, 'operation:tag:delete', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('61', '66', '图书管理', 'book/book', null, '1', 'list', '3');
INSERT INTO `sys_menu` VALUES ('62', '61', '查看', null, 'book:list,book:info', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('63', '61', '新增', null, 'book:save', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('64', '61', '修改', null, 'book:update', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('65', '61', '删除', null, 'book:delete', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('66', '0', '阅读管理', null, null, '0', 'read', '1');
INSERT INTO `sys_menu` VALUES ('67', '66', '新增图书', 'book/book-add-or-update', '', '1', 'add', '1');
INSERT INTO `sys_menu` VALUES ('68', '66', '笔记管理', 'book/note', null, '1', 'list', '2');
INSERT INTO `sys_menu` VALUES ('69', '68', '查看', null, 'book:note:list,book:note:info', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('70', '68', '新增', null, 'book:note:save', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('71', '68', '修改', null, 'book:note:update', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('72', '68', '删除', null, 'book:note:delete', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('73', '66', '新增笔记', 'book/note-add-or-update', '', '1', 'add', '0');
INSERT INTO `sys_menu` VALUES ('74', '43', '友链管理', 'operation/link', null, '1', 'link', '6');
INSERT INTO `sys_menu` VALUES ('75', '74', '查看', null, 'operation:link:list,operation:link:info', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('76', '74', '新增', null, 'operation:link:save', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('77', '74', '修改', null, 'operation:link:update', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('78', '74', '删除', null, 'operation:link:delete', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('79', '43', '推荐管理', 'operation/recommend', null, '1', 'recommend', '6');
INSERT INTO `sys_menu` VALUES ('80', '79', '查看', null, 'operation:recommend:list,operation:recommend:info', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('81', '79', '新增', null, 'operation:recommend:save', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('82', '79', '修改', null, 'operation:recommend:update', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('83', '79', '删除', null, 'operation:recommend:delete', '2', null, '6');
INSERT INTO `sys_menu` VALUES ('84', '32', '刷新缓存', null, 'article:cache:refresh', '2', null, '0');

-- ----------------------------
-- Table structure for sys_param
-- ----------------------------
DROP TABLE IF EXISTS `sys_param`;
CREATE TABLE `sys_param` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `par_key` int(11) DEFAULT NULL COMMENT '参数key',
  `par_value` varchar(255) DEFAULT NULL COMMENT '参数值',
  `menu_url` varchar(255) DEFAULT NULL COMMENT '菜单URL',
  `type` varchar(255) DEFAULT NULL COMMENT '菜单类型',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 COMMENT='系统参数表';

-- ----------------------------
-- Records of sys_param
-- ----------------------------
INSERT INTO `sys_param` VALUES ('2', '1', '一级', '/operation-category', 'CATEGORY_RANK', '2020-01-24 16:37:30', '2020-01-24 16:37:34');
INSERT INTO `sys_param` VALUES ('3', '2', '二级', '/operation-category', 'CATEGORY_RANK', '2020-01-24 16:38:02', '2020-01-24 16:38:02');
INSERT INTO `sys_param` VALUES ('4', '3', '三级', '/operation-category', 'CATEGORY_RANK', '2020-01-24 16:38:18', '2020-01-24 16:38:18');
INSERT INTO `sys_param` VALUES ('7', '1', '小图片', '/article-addOrUpdate', 'ARTICLE_COVER_TYPE', '2020-01-24 16:38:46', '2020-01-24 16:38:46');
INSERT INTO `sys_param` VALUES ('8', '2', '大图片', '/article-addOrUpdate', 'ARTICLE_COVER_TYPE', '2020-01-24 16:38:58', '2020-01-24 16:38:58');
INSERT INTO `sys_param` VALUES ('9', '3', '无图片', '/article-addOrUpdate', 'ARTICLE_COVER_TYPE', '2020-01-24 16:39:12', '2020-01-24 16:39:12');
INSERT INTO `sys_param` VALUES ('10', '0', '文章', null, 'MODULE_TYPE', '2020-01-24 16:39:23', '2020-01-24 16:39:23');
INSERT INTO `sys_param` VALUES ('11', '1', '图书', null, 'MODULE_TYPE', '2020-01-24 16:39:41', '2020-01-24 16:39:41');
INSERT INTO `sys_param` VALUES ('12', '2', '笔记', null, 'MODULE_TYPE', '2020-01-24 16:39:50', '2020-01-24 16:39:50');

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `role_name` varchar(100) NOT NULL DEFAULT '' COMMENT '角色名称',
  `remark` varchar(255) DEFAULT NULL COMMENT '备注',
  `create_user_id` varchar(40) DEFAULT NULL COMMENT '创建者ID',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1242364441769582594 DEFAULT CHARSET=utf8 COMMENT='角色表';

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES ('1', 'role1', '1', '1', '2020-03-19 13:32:46', '2020-03-19 13:32:46');
INSERT INTO `sys_role` VALUES ('2', 'role2', '2', '1', '2020-03-19 13:32:56', '2020-03-19 13:32:56');
INSERT INTO `sys_role` VALUES ('6', '1', '1', '1', '2020-03-19 16:01:17', '2020-03-19 16:01:17');

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `role_id` bigint(40) NOT NULL COMMENT '角色ID',
  `menu_id` bigint(40) NOT NULL COMMENT '菜单ID',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1242366714310602754 DEFAULT CHARSET=utf8 COMMENT='角色菜单对应关系表';

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES ('38', '6', '2', '2020-03-19 16:01:17', '2020-03-19 16:01:17');
INSERT INTO `sys_role_menu` VALUES ('39', '6', '15', '2020-03-19 16:01:17', '2020-03-19 16:01:17');
INSERT INTO `sys_role_menu` VALUES ('40', '6', '16', '2020-03-19 16:01:17', '2020-03-19 16:01:17');
INSERT INTO `sys_role_menu` VALUES ('41', '6', '17', '2020-03-19 16:01:17', '2020-03-19 16:01:17');
INSERT INTO `sys_role_menu` VALUES ('42', '6', '18', '2020-03-19 16:01:17', '2020-03-19 16:01:17');
INSERT INTO `sys_role_menu` VALUES ('43', '6', '1', '2020-03-19 16:01:17', '2020-03-19 16:01:17');

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
  `username` varchar(10) NOT NULL COMMENT '角色名称',
  `password` varchar(255) NOT NULL COMMENT '密码',
  `email` varchar(20) DEFAULT NULL COMMENT '邮箱',
  `salt` varchar(20) DEFAULT NULL COMMENT '加密算法',
  `status` varchar(20) DEFAULT NULL COMMENT '状态',
  `create_user_id` varchar(40) DEFAULT NULL COMMENT '创建者ID',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1242354239464853506 DEFAULT CHARSET=utf8 COMMENT='用户表';

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES ('1', 'lxy', '1234', null, null, '1', '1', '2020-01-22 17:37:52', '2020-01-22 17:37:52');
INSERT INTO `sys_user` VALUES ('1242354239464853505', '1', '2', '1@qq.com', null, '1', '1', '2020-03-24 07:35:07', '2020-03-24 08:00:17');

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role` (
  `id` bigint(40) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(40) DEFAULT NULL COMMENT '用户ID',
  `role_id` bigint(40) DEFAULT NULL COMMENT '角色ID',
  `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1242360572993875971 DEFAULT CHARSET=utf8 COMMENT='用户与角色对应关系';

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES ('1241981531174514689', '1241981531161931778', '6', '2020-03-23 06:54:07', '2020-03-23 06:54:07');
INSERT INTO `sys_user_role` VALUES ('1242360572624777218', '1242354239464853505', '6', '2020-03-24 08:00:17', '2020-03-24 08:00:17');
INSERT INTO `sys_user_role` VALUES ('1242360572993875970', '1242354239464853505', '2', '2020-03-24 08:00:17', '2020-03-24 08:00:17');
